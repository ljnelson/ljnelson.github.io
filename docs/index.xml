<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home on Blame Laird</title>
    <link>https://ljnelson.github.io/</link>
    <description>Recent content in Home on Blame Laird</description>
    <generator>Hugo -- gohugo.io</generator>
    <managingEditor>ljnelson@gmail.com (Laird Nelson)</managingEditor>
    <webMaster>ljnelson@gmail.com (Laird Nelson)</webMaster>
    <lastBuildDate>Thu, 16 Dec 2021 14:37:22 -0800</lastBuildDate><atom:link href="https://ljnelson.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Paths</title>
      <link>https://ljnelson.github.io/blog/paths/</link>
      <pubDate>Sun, 10 Apr 2022 10:52:18 -0700</pubDate>
      <author>ljnelson@gmail.com (Laird Nelson)</author>
      <guid>https://ljnelson.github.io/blog/paths/</guid>
      <description>&lt;div&gt;
  &lt;h2 id=&#34;table-of-contents&#34;&gt;Table Of Contents&lt;/h2&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;&lt;/nav&gt;
&lt;/div&gt;

&lt;h1 id=&#34;paths&#34;&gt;Paths&lt;/h1&gt;
&lt;p&gt;In this ongoing series related to Java configuration, I&amp;rsquo;ve most
recently covered &lt;a href=&#34;https://ljnelson.github.io/blog/service-loader-requests/&#34;&gt;what it might look like if you had a &lt;code&gt;ServiceLoader&lt;/code&gt;
that could take requests&lt;/a&gt;.  I introduced the notion of a &lt;em&gt;path&lt;/em&gt;, a sparsely populated
pointer of sorts to objects in objectspace.  Paths are not new, of
course, and are present in everything from filesystems to JNDI to
Jakarta RESTful Web Services.&lt;/p&gt;
&lt;p&gt;In this post I&amp;rsquo;d like to dive a little deeper into how a path might be
put together.&lt;/p&gt;
&lt;p&gt;A path is used for addressing, so we want it to be as specific as we
can possibly get it.  What does that mean?&lt;/p&gt;
&lt;p&gt;Many times when we think about paths we think of them as if they were
simply names.  Their elements, in this model, are simple strings, and
they are separated by some kind of a separator, and that&amp;rsquo;s it.&lt;/p&gt;
&lt;p&gt;This isn&amp;rsquo;t nearly enough for a configuration system addressing
scheme.  Weirdly, several different configuration systems take this
approach, and it is exactly &lt;em&gt;because&lt;/em&gt; they take this approach that
they are deficient.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s look back at JNDI again.  While JNDI paths consist of name
elements in a sequence, each element also has an
&lt;a href=&#34;https://docs.oracle.com/en/java/javase/17/docs/api/java.naming/javax/naming/Context.html#getEnvironment()&#34;&gt;environment&lt;/a&gt;.
An environment in this system is just a bunch of key value pairs that
&amp;ldquo;ride with&amp;rdquo; the path element (named &lt;code&gt;Context&lt;/code&gt; in JNDI).&lt;/p&gt;
&lt;p&gt;Or let&amp;rsquo;s look at Jakarta RESTful Web Services again.  While paths
there also consist of elements in a sequence, there are also headers
and matrix parameters that might logically belong to each element in
the sequence.  More key value pairs, if you squint in the right way.&lt;/p&gt;
&lt;p&gt;Finally, if you look at all paths in a certain way, you can see that
at their absolute heart they are &lt;em&gt;nothing more than key value pairs
all the way down&lt;/em&gt;.  They aren&amp;rsquo;t &lt;em&gt;represented&lt;/em&gt; this way, of course, but
fundamentally a JNDI &lt;code&gt;Context&lt;/code&gt; with an environment that contains &lt;code&gt;a = b&lt;/code&gt; and that is identified by a name of &lt;code&gt;a/b/c&lt;/code&gt; is really just a
collection of key value pairs that consists of &lt;code&gt;{a = b, name = a/b/c}&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This insight is kind of important.  It means that when a loader
receives a request to load an object, it is, at some fundamental
level, receiving an immutable set of key value pairs describing the
request.  Once you see this you can&amp;rsquo;t unsee it, and
names-with-separators addressing schemes just don&amp;rsquo;t measure up.&lt;/p&gt;
&lt;p&gt;It is nevertheless true that some of these key value pairs are often
more important to the human reader than others.  In the case of a JNDI
&lt;code&gt;Context&lt;/code&gt;, the name itself is quite important since you always have to
have one and the way it is represented indicates the depth of a
hierarchy that might or might not be present.  Similarly, in Jakarta
RESTful Web Services, the length of a path often tells you something,
just by looking at it, about the specificity of the request.  So
representing the value of a hypothetical &lt;code&gt;name&lt;/code&gt; key with a value that
is a sequence of names makes some sense.&lt;/p&gt;
&lt;p&gt;(Names, as frequently mentioned on this blog, always have implicit
namespaces, so it&amp;rsquo;s important that paths&amp;rsquo; names be able to be
&lt;em&gt;transliterated&lt;/em&gt;: if you, a class developer, decide that your path is
going to have a name of &lt;code&gt;a/b&lt;/code&gt;, and I, an application assembler, know
that &lt;code&gt;a/b&lt;/code&gt; is already spoken for by another class developer, then I
have to have a way to reconcile this name clash.)&lt;/p&gt;
&lt;p&gt;Similarly, there are plenty of implicit key value pairs that are part
of a path even when the path builder doesn&amp;rsquo;t supply them explicitly.
For example, the current &lt;code&gt;Locale&lt;/code&gt; or operating system might very well
be a key whose value might help a loader find an appropriate object.
Frequently these sorts of situational parameter values are not
explicitly supplied by a user, but are understood nevertheless to be
part of the loading request.  Making these of secondary concern seems
like a good thing to do.&lt;/p&gt;
&lt;p&gt;Finally, paths in all systems that use them have an implicit or
explicit &lt;em&gt;type&lt;/em&gt;.  A filesystem path ends in a type
(e.g. &lt;code&gt;java.io.File&lt;/code&gt; or &lt;code&gt;java.nio.file.Path&lt;/code&gt;).  A JNDI &lt;code&gt;Name&lt;/code&gt; ends in
a type, but Java lacked the syntax to fully describe it; you can see
the footprints in the
&lt;a href=&#34;https://docs.oracle.com/en/java/javase/17/docs/api/java.naming/javax/naming/NameClassPair.html&#34;&gt;&lt;code&gt;NameClassPair&lt;/code&gt;&lt;/a&gt;
class.  A Jakarta RESTful Web Services path (of type &lt;code&gt;GET&lt;/code&gt; (oh look,
another key value pair that rides with the request!)) terminates in an
entity of a particular type.  The type is, of course, just another key
value pair, logically speaking (&lt;code&gt;type = java.nio.file.Path&lt;/code&gt;), but is
also a key value pair that is borne by all paths.  So it might make
sense to represent it explicitly and elevate its primacy.&lt;/p&gt;
&lt;p&gt;When we put this all together we get something like this:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;code&gt;Path&lt;/code&gt; is a sequence of &lt;code&gt;Path.Element&lt;/code&gt;s.&lt;/li&gt;
&lt;li&gt;A &lt;code&gt;Path&lt;/code&gt; has &lt;code&gt;Qualifiers&lt;/code&gt; that are the key value pairs that qualify
it.&lt;/li&gt;
&lt;li&gt;A &lt;code&gt;Path&lt;/code&gt;&amp;rsquo;s final &lt;code&gt;Path.Element&lt;/code&gt; has a type, which is also the type
of the &lt;code&gt;Path&lt;/code&gt;.
&lt;ul&gt;
&lt;li&gt;Other &lt;code&gt;Path.Element&lt;/code&gt;s need not have a type.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Each &lt;code&gt;Path.Element&lt;/code&gt; has a name.
&lt;ul&gt;
&lt;li&gt;A &lt;code&gt;Path.Element&lt;/code&gt; must be able to be transliterated without
changing source code.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Each &lt;code&gt;Path.Element&lt;/code&gt; has &lt;code&gt;Qualifiers&lt;/code&gt; that qualify it and no other
&lt;code&gt;Path.Element&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Any given &lt;code&gt;Path.Element&lt;/code&gt; may or may not have a type, but a
&lt;code&gt;Path.Element&lt;/code&gt; that ends a &lt;code&gt;Path&lt;/code&gt; must have a type.&lt;/li&gt;
&lt;li&gt;A &lt;code&gt;Path&lt;/code&gt;&amp;rsquo;s &lt;code&gt;Qualifiers&lt;/code&gt; includes qualifiers that qualify the path
as a whole as well as the appropriately-scoped &lt;code&gt;Qualifiers&lt;/code&gt; from
each of its &lt;code&gt;Path.Element&lt;/code&gt;s.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note that each &lt;code&gt;Path.Element&lt;/code&gt; in the model described above does not
have a type (paths can be sparsely populated).  So this does not
imply any kind of hierarchy, nor should it.&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;ve quietly introduced the notion of a &lt;code&gt;Qualifiers&lt;/code&gt;, which is
basically a read-only set of immutable key value pairs with a defined
iteration order.  A &lt;code&gt;Qualifiers&lt;/code&gt; may be empty.&lt;/p&gt;
&lt;p&gt;Again, just for the thought experiment, it&amp;rsquo;s worth remembering that a
&lt;code&gt;Path&lt;/code&gt; could be fully represented as a &lt;code&gt;Map&lt;/code&gt; with required &lt;code&gt;name&lt;/code&gt; and
&lt;code&gt;type&lt;/code&gt; keys that have non-&lt;code&gt;null&lt;/code&gt; values.  But for the reasons listed
above it&amp;rsquo;s better to represent it as its own thing.&lt;/p&gt;
&lt;p&gt;Since I&amp;rsquo;m proposing to build &lt;code&gt;Path&lt;/code&gt;s around &lt;code&gt;Qualifiers&lt;/code&gt;, the next
post will dive into them a little more deeply.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Service Loader Requests</title>
      <link>https://ljnelson.github.io/blog/service-loader-requests/</link>
      <pubDate>Fri, 28 Jan 2022 14:52:27 -0800</pubDate>
      <author>ljnelson@gmail.com (Laird Nelson)</author>
      <guid>https://ljnelson.github.io/blog/service-loader-requests/</guid>
      <description>&lt;div&gt;
  &lt;h2 id=&#34;table-of-contents&#34;&gt;Table Of Contents&lt;/h2&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#what-would-a-serviceloader-that-could-take-requests-look-like&#34;&gt;What Would a &lt;code&gt;ServiceLoader&lt;/code&gt; That Could Take Requests Look Like?&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#objectspace&#34;&gt;Objectspace&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#ambiguity&#34;&gt;Ambiguity&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#addressing&#34;&gt;Addressing&lt;/a&gt;
          &lt;ul&gt;
            &lt;li&gt;&lt;a href=&#34;#serviceloader-addressing&#34;&gt;&lt;code&gt;ServiceLoader&lt;/code&gt; Addressing&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&#34;#jakarta-restful-web-services-addressing&#34;&gt;Jakarta RESTful Web Services Addressing&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&#34;#jndi-addressing&#34;&gt;JNDI Addressing&lt;/a&gt;&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#loaders-paths-and-qualifiers&#34;&gt;Loaders, Paths and Qualifiers&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#whats-next&#34;&gt;What&amp;rsquo;s Next?&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;/div&gt;

&lt;h2 id=&#34;what-would-a-serviceloader-that-could-take-requests-look-like&#34;&gt;What Would a &lt;code&gt;ServiceLoader&lt;/code&gt; That Could Take Requests Look Like?&lt;/h2&gt;
&lt;p&gt;In this ongoing series related to Java configuration, I&amp;rsquo;ve covered
&lt;a href=&#34;https://ljnelson.github.io/blog/java-configuration-jndi-and-naming-operations/&#34;&gt;JNDI&lt;/a&gt;
and &lt;a href=&#34;https://ljnelson.github.io/blog/java-configuration-jaxrs-as-a-configuration-system/&#34;&gt;Jakarta RESTful Web Services&lt;/a&gt;.  Both
involve loading Java &lt;code&gt;Object&lt;/code&gt;s from potentially many providers with
disambiguation algorithms built in, and both permit the application
assembler to work around naming clashes.  Of course, neither is a Java
configuration system.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s look at some of the super-concepts these two technologies have
in common.&lt;/p&gt;
&lt;h3 id=&#34;objectspace&#34;&gt;Objectspace&lt;/h3&gt;
&lt;p&gt;The first is what I&amp;rsquo;ll call, somewhat pretentiously, &lt;em&gt;objectspace&lt;/em&gt;.
This is the notional space of all possible Java objects (and
primitive types) in all possible Java virtual machines in all possible
worlds.  Objectspace is big.&lt;/p&gt;
&lt;p&gt;You can pick out an individual object from objectspace, let&amp;rsquo;s say, by
supplying some &lt;em&gt;loading system&lt;/em&gt; with an &lt;em&gt;address&lt;/em&gt;.  (This sounds like
pointers!  Indeed, that&amp;rsquo;s part of the analogy I&amp;rsquo;m going for.)  Give
the system an address, it hands you back the corresponding object.  By
definition, if you provide a precise enough address there will be
exactly one object it picks out, never zero.  Simple.  What could
possibly go wrong?&lt;/p&gt;
&lt;p&gt;To get an object from objectspace according to the rules as I&amp;rsquo;ve laid
them out so far, you have to be &lt;em&gt;remarkably&lt;/em&gt; precise.  You&amp;rsquo;d better be
able to distinguish objects by type, certainly, and whatever the
addressing scheme looks like, it better take type into account.  But
you can&amp;rsquo;t stop there.&lt;/p&gt;
&lt;h3 id=&#34;ambiguity&#34;&gt;Ambiguity&lt;/h3&gt;
&lt;p&gt;If we &lt;em&gt;do&lt;/em&gt; stop there, we have to address ambiguity.  If I ask for
what I hope is the only &lt;code&gt;String&lt;/code&gt; in all of objectspace by asking a
hypothetical loading system for the one true object that has the type
&lt;code&gt;String.class&lt;/code&gt;, the loading system will laugh in my face.  There are
many &lt;code&gt;String&lt;/code&gt;s in objectspace.&lt;/p&gt;
&lt;p&gt;OK, OK; I might instead want to ask this hypothetical loading system
for a very particular &lt;code&gt;String&lt;/code&gt;, namely the one in objectspace under
the System property key &lt;code&gt;java.home&lt;/code&gt;.  But even this isn&amp;rsquo;t specific
enough, since, remember, objectspace encompasses all Java objects in
the universe.  There are many Java homes.  The one that identifies
&lt;em&gt;my&lt;/em&gt; Java installation is just one of them!  And yet I get a single
&lt;code&gt;String&lt;/code&gt; back, so, Laird, your analogy sucks.&lt;/p&gt;
&lt;h3 id=&#34;addressing&#34;&gt;Addressing&lt;/h3&gt;
&lt;p&gt;Not so fast!  When I ask for this hypothetical loading system to give
me the &lt;code&gt;java.home&lt;/code&gt; &lt;code&gt;String&lt;/code&gt;, I&amp;rsquo;m actually supplying plenty of other
implicit addressing information in my request, whether I know I&amp;rsquo;m
doing this or not.  Specifically, I&amp;rsquo;m &lt;em&gt;actually&lt;/em&gt; asking for the only
&lt;code&gt;String&lt;/code&gt; in all of objectspace that has the type &lt;code&gt;String.class&lt;/code&gt;, that
is indexed under the System property key &lt;code&gt;java.home&lt;/code&gt;, and on this JVM,
running on this machine, on this architecture, in this universe, and
so on and so forth.  That &lt;em&gt;may&lt;/em&gt; be enough to pick out the &lt;code&gt;String&lt;/code&gt; I
want (and normally is in non-hypothetical, non-abstract,
non-&lt;a href=&#34;https://www.joelonsoftware.com/2001/04/21/dont-let-architecture-astronauts-scare-you/&#34;&gt;architecture
astronaut&lt;/a&gt;
cases).&lt;/p&gt;
&lt;p&gt;So types and JVM-wide names seem to be the bare minimum to pick out an
object from all of objectspace.  Sounds easy—but that&amp;rsquo;s not quite
right either.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s say instead that I would like this loading system to fetch me
the one true &lt;code&gt;String&lt;/code&gt; that can be found in some hazy way &amp;ldquo;under&amp;rdquo; the
name &lt;code&gt;preferredHost&lt;/code&gt; (I made this up so that it&amp;rsquo;s not some key defined
by Java itself).  Let&amp;rsquo;s further wave our hands about possible name
collisions: let&amp;rsquo;s pretend that no other developer in the entire
universe could possibly ever be writing a class like mine, and no
other developer in the entire universe could possibly ever mean
anything semantically different from what I mean when I say
&lt;code&gt;preferredHost&lt;/code&gt;.  (In practice, of course, these assumptions are
completely ridiculous.  Bear with me; we&amp;rsquo;ll get there.)&lt;/p&gt;
&lt;p&gt;But if my application is running in &lt;code&gt;test&lt;/code&gt;, in some sort of hazy way,
then there may very well be an ambiguity here.  &lt;code&gt;preferredHost&lt;/code&gt; and
&lt;code&gt;String.class&lt;/code&gt; no longer uniquely identify a &lt;code&gt;String&lt;/code&gt; in objectspace.
Maybe there is another string value indexed under &lt;code&gt;preferredHost&lt;/code&gt; in
objectspace (that identifies the &lt;code&gt;production&lt;/code&gt; &lt;code&gt;preferredHost&lt;/code&gt; for
example).  Oh, shoot, I guess really what I was asking for all along
was the one true &lt;code&gt;String&lt;/code&gt; indexed under the explicit name
&lt;code&gt;preferredHost&lt;/code&gt; and the implicit name &lt;code&gt;test&lt;/code&gt;.  (Note that in no way
was I asking for the explicit name &lt;code&gt;test.preferredHost&lt;/code&gt;, nor did I
have some kind of fallback in mind.)  As a component developer, I of
course didn&amp;rsquo;t know what application my component was running in, so it
didn&amp;rsquo;t occur to me to check for this case.  Oops.&lt;/p&gt;
&lt;p&gt;Objectspace is &lt;em&gt;big&lt;/em&gt;.  Like, &lt;a href=&#34;https://www.goodreads.com/quotes/14434-space-is-big-you-just-won-t-believe-how-vastly-hugely&#34;&gt;you just won&amp;rsquo;t believe how vastly,
hugely, mind-bogglingly big it
is&lt;/a&gt;.
Picking out a single &lt;code&gt;Object&lt;/code&gt; in it is damn near impossible.&lt;/p&gt;
&lt;p&gt;Instead, typically what we do, while blissfully not being aware of it,
is: we supply &lt;em&gt;some&lt;/em&gt; addressing information, and then rely on some
common case where we were expecting one thing, and there was only one
thing that happened to match our imprecise addressing information, and
we asked our loading system for it, and it responded, and we got only
one thing, not 27, and it never occurs to us that 27 of those things
is actually a very real possibility.  Then the bugs roll in.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Good loading system APIs recognize that no addressing system you can
come up with will ever pick out an object from objectspace without
some kind of further disambiguation.&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;serviceloader-addressing&#34;&gt;&lt;code&gt;ServiceLoader&lt;/code&gt; Addressing&lt;/h4&gt;
&lt;p&gt;Let&amp;rsquo;s look at
&lt;a href=&#34;https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/ServiceLoader.html&#34;&gt;&lt;code&gt;java.util.ServiceLoader&lt;/code&gt;&lt;/a&gt;
as an example.  This class deliberately embraces ambiguity.  The only
kind of addressing information you can give it is type.  Ask a
&lt;code&gt;ServiceLoader&lt;/code&gt; for the thing corresponding to &lt;code&gt;SomeService.class&lt;/code&gt;,
and it will hand you back an &lt;code&gt;Iterable&amp;lt;SomeService&amp;gt;&lt;/code&gt;.  Anyone can put
a service provider file on the classpath (discoverable as a classpath
resource at &lt;code&gt;META-INF/services/com.foo.SomeService&lt;/code&gt;, let&amp;rsquo;s say), and
its entries will be picked up.  So great, how do you filter all the
various &lt;code&gt;SomeService&lt;/code&gt; implementors?  That, dear reader, is up to you.&lt;/p&gt;
&lt;p&gt;The upshot is: &lt;code&gt;ServiceLoader&lt;/code&gt;, like many loading systems, accounts
for the almost completely necessary ambiguity of objectspace in its
API design.  Ask for a thing of a type, get back many things of that
type.  Your problem to solve.&lt;/p&gt;
&lt;h4 id=&#34;jakarta-restful-web-services-addressing&#34;&gt;Jakarta RESTful Web Services Addressing&lt;/h4&gt;
&lt;p&gt;Let&amp;rsquo;s consider Jakarta RESTful Web Services.  Let&amp;rsquo;s pretend that
Jakarta RESTful Web Services is, among other things, a way to (again,
partially) address into objectspace.  After all, with a resource
method you can say, effectively, &amp;ldquo;this method will return a
&lt;code&gt;SomeService&lt;/code&gt; if the addressing information matches the path &lt;code&gt;a/b/c&lt;/code&gt;
and the media type &lt;code&gt;application/json&lt;/code&gt;.&amp;rdquo;.  So if you ask &lt;em&gt;this&lt;/em&gt; loading
system for a &lt;code&gt;SomeService.class&lt;/code&gt; object, providing no path information
and no media type information, the ambiguity is reduced somewhat: this
resource method I described will not &amp;ldquo;fire&amp;rdquo; and it, at least, will not
be responsible for returning a &lt;code&gt;SomeService&lt;/code&gt;.  Some other resource
method might.  If more than one &amp;ldquo;fires&amp;rdquo;, then there is an algorithm
that somewhat arbitrarily picks one.&lt;/p&gt;
&lt;h4 id=&#34;jndi-addressing&#34;&gt;JNDI Addressing&lt;/h4&gt;
&lt;p&gt;Let&amp;rsquo;s consider JNDI.  Let&amp;rsquo;s pretend that JNDI is, among other things,
a way to (again, partially) address into objectspace.  After all, with
a
&lt;a href=&#34;https://docs.oracle.com/en/java/javase/17/docs/api/java.naming/javax/naming/spi/ObjectFactory.html&#34;&gt;&lt;code&gt;javax.naming.spi.ObjectFactory&lt;/code&gt;&lt;/a&gt;
you can say, effectively, &amp;ldquo;this &lt;code&gt;ObjectFactory&lt;/code&gt; will return a
&lt;code&gt;SomeService&lt;/code&gt; if the addressing information matches the &lt;a href=&#34;https://docs.oracle.com/en/java/javase/17/docs/api/java.naming/javax/naming/CompoundName.html&#34;&gt;compound
name&lt;/a&gt;
&lt;code&gt;a/b/c&lt;/code&gt; and an expected
&lt;a href=&#34;https://docs.oracle.com/en/java/javase/17/docs/api/java.naming/javax/naming/spi/ObjectFactory.html#getObjectInstance(java.lang.Object,javax.naming.Name,javax.naming.Context,java.util.Hashtable)&#34;&gt;&lt;code&gt;environment&lt;/code&gt;&lt;/a&gt;.&amp;rdquo;
So if you ask &lt;em&gt;this&lt;/em&gt; loading system for a &lt;code&gt;SomeService.class&lt;/code&gt; object,
providing no compound name information and no environment information,
the ambiguity is reduced somewhat: this &lt;code&gt;ObjectFactory&lt;/code&gt; I described
will not &amp;ldquo;fire&amp;rdquo; and it, at least, will not be responsible for
returning a &lt;code&gt;SomeService&lt;/code&gt;.  Some other &lt;code&gt;ObjectFactory&lt;/code&gt; might.  If more
than one &amp;ldquo;fires&amp;rdquo;, then there is an algorithm that somewhat arbitrarily
picks one.&lt;/p&gt;
&lt;p&gt;(You of course see the similarity.)&lt;/p&gt;
&lt;p&gt;Each of these loading systems differs, of course, in what its
&amp;ldquo;loaders&amp;rdquo; are permitted to do (resource methods and &lt;code&gt;ObjectFactory&lt;/code&gt;
instances have to play by the rules of their specifications).  And
each loading system permits more or less addressing information to
&amp;ldquo;ride along&amp;rdquo; with the general request for a typed Java &lt;code&gt;Object&lt;/code&gt; from
objectspace, to help pare down the possible matching objects to a
manageable number.  But they&amp;rsquo;re very similar when we look at them as
object loading systems that accept reasonably fine-grained addressing
information that identifies many things, but hopefully not lots of
things.&lt;/p&gt;
&lt;p&gt;Finally, each of these systems is not a Java configuration system!
But you know what is a configuration system, of a sort?
&lt;code&gt;java.util.ServiceLoader&lt;/code&gt;.  It is a configuration system that just so
happens to have punted the problem of resolving ambiguity to the end
user.  It is also designed to satisfy only one of several
configuration-related use cases, which it does very well.  What if we
augmented &lt;code&gt;ServiceLoader&lt;/code&gt; with the ability to receive some kind of
addressing information that would allow it to avoid ambiguity in more
cases than it does right now?  What would we need to add?&lt;/p&gt;
&lt;h3 id=&#34;loaders-paths-and-qualifiers&#34;&gt;Loaders, Paths and Qualifiers&lt;/h3&gt;
&lt;p&gt;First, let&amp;rsquo;s talk terminology.  A configuration system doesn&amp;rsquo;t just
load services, so we&amp;rsquo;ll drop that word.  So &lt;code&gt;ServiceLoader&lt;/code&gt; will
become &lt;code&gt;Loader&lt;/code&gt; for this discussion, and &amp;ldquo;service provider&amp;rdquo; will
become &amp;ldquo;provider&amp;rdquo;, and so on.&lt;/p&gt;
&lt;p&gt;Next, we need a good word for our addressing information.  We can look
to JNDI and Jakarta RESTful web services here.  In JNDI, the
addressing information is termed a &lt;em&gt;name&lt;/em&gt;.  In Jakarta RESTful Web
Services, the addressing information is termed a &lt;em&gt;path&lt;/em&gt; (since of
course it is concerned with URIs).  I like &lt;em&gt;path&lt;/em&gt; better than &lt;em&gt;name&lt;/em&gt;
for addressing information because it implies a type (a filesystem
path yields a file, for example; a Jakarta RESTful Web Services path
yields an object of a particular media type) and can either imply a
tree structure or not, depending on how it&amp;rsquo;s used.  It&amp;rsquo;s also about
finding your way to a destination.  So we&amp;rsquo;ll go with path.&lt;/p&gt;
&lt;p&gt;The kind of path we&amp;rsquo;ll talk about is similar to Jakarta RESTful Web
Services&amp;rsquo; path: it is sparse.  That is, it&amp;rsquo;s not the case that every
element in a path necessarily identifies an object at that location
(in direct contrast with JNDI, where every atomic name in a compound
name identifies a context).  In this regard, a path is like a pointer
or a probe: ultimately what matters is what it picks out at the end,
not the intermediate objects that may exist along the way.&lt;/p&gt;
&lt;p&gt;Our path will also need to have the ability to pass additional
addressing information.  JNDI has &lt;a href=&#34;https://docs.oracle.com/en/java/javase/17/docs/api/java.naming/javax/naming/Context.html#:~:text=provider%20may%20not.-,Environment%20Properties,-JNDI%20applications%20need&#34;&gt;environment
properties&lt;/a&gt;.
Jakarta RESTful Web Services provides resource methods with the
ability to inspect headers, query string parameters, path parameters
and matrix parameters.  Each of these facilities is a way to further
&lt;em&gt;qualify&lt;/em&gt; a request.  We&amp;rsquo;ll consequently follow in the &lt;a href=&#34;https://jakarta.ee/specifications/cdi/3.0/jakarta-cdi-spec-3.0.html#qualifiers&#34;&gt;terminological
footsteps of systems like
CDI&lt;/a&gt;
and call this additional addressing information &lt;em&gt;qualifiers&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Putting it all together, a &lt;em&gt;path&lt;/em&gt; is a &lt;em&gt;typed&lt;/em&gt; and &lt;em&gt;qualified&lt;/em&gt;
ordered sequence of &lt;em&gt;elements&lt;/em&gt; that identifies zero or more objects in
objectspace.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A &lt;em&gt;loader&lt;/em&gt; is a component that dereferences a path.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If you look at things this way, then a &lt;code&gt;java.util.ServiceLoader&lt;/code&gt; is a
loader that dereferences very particular kinds of paths, namely those
that have a type, zero elements and no qualifiers.&lt;/p&gt;
&lt;h2 id=&#34;whats-next&#34;&gt;What&amp;rsquo;s Next?&lt;/h2&gt;
&lt;p&gt;We&amp;rsquo;re on our way, but we&amp;rsquo;re not there yet.  What lies at the end of
any path is not necessarily an object, but may be nothing or many
objects.  Also, since in the real world the objectspace we&amp;rsquo;re dealing
with at any given time in any given system is actually fairly small
and sparsely populated, we might want a strategy for what to do when a
path doesn&amp;rsquo;t actually identify anything but something else might be
&lt;em&gt;suitable&lt;/em&gt; for it.&lt;/p&gt;
&lt;p&gt;Additionally, even if a path &lt;em&gt;does&lt;/em&gt; identify something, it may come
and go over time, being &lt;em&gt;temporarily&lt;/em&gt; or &lt;em&gt;permanently&lt;/em&gt; &lt;em&gt;absent&lt;/em&gt; or
&lt;em&gt;present&lt;/em&gt;.  What our loader loads may therefore need to be not the
object itself, but some kind of dereferencer that is pinned to the
path that yielded it.&lt;/p&gt;
&lt;p&gt;There is also the notion of an application&amp;rsquo;s &lt;em&gt;environment&lt;/em&gt; to be
concerned with.  An application&amp;rsquo;s environment is the portion of
objectspace it inhabits (the machine it lives on, the locale it&amp;rsquo;s in,
various other automatic and implicit coordinates, and the
human-authored configuration that is suitable for it), which includes
parts that a &lt;em&gt;component&lt;/em&gt; of that application, asking for an object to
be loaded, is unaware of, but that are necessary to include with the
addressing information.  Other environments within objectspace may or
may not be suitable for a loader to consider when trying to
dereference a path.&lt;/p&gt;
&lt;p&gt;The journey continues; stay tuned.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java Configuration: JAX-RS as a Configuration System</title>
      <link>https://ljnelson.github.io/blog/java-configuration-jaxrs-as-a-configuration-system/</link>
      <pubDate>Sat, 01 Jan 2022 12:45:33 -0800</pubDate>
      <author>ljnelson@gmail.com (Laird Nelson)</author>
      <guid>https://ljnelson.github.io/blog/java-configuration-jaxrs-as-a-configuration-system/</guid>
      <description>&lt;div&gt;
  &lt;h2 id=&#34;table-of-contents&#34;&gt;Table Of Contents&lt;/h2&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#background-and-rationale&#34;&gt;Background and Rationale&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#jakarta-rest-as-a-configuration-system&#34;&gt;Jakarta REST as a Configuration System?!&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#the-foundation&#34;&gt;The Foundation&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#configuration-concerns&#34;&gt;Configuration Concerns&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#disambiguation&#34;&gt;Disambiguation&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#suitability&#34;&gt;Suitability&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#conclusion&#34;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;/div&gt;

&lt;h2 id=&#34;background-and-rationale&#34;&gt;Background and Rationale&lt;/h2&gt;
&lt;p&gt;I&amp;rsquo;ve &lt;a href=&#34;https://ljnelson.github.io/blog/java-configuration-jndi-and-naming-operations/&#34;&gt;written previously&lt;/a&gt; about looking at
JNDI through a Java-centric configuration system design lens.  Here
I&amp;rsquo;ll do something similar with the JAX-RS specification (now known as
{deep breath} &lt;a href=&#34;https://jakarta.ee/specifications/restful-ws/3.0/&#34;&gt;Jakarta RESTful Web
Services&lt;/a&gt;, or,
hopefully soon, simply Jakarta REST, which is how I&amp;rsquo;ll refer to it in
this article).&lt;/p&gt;
&lt;h2 id=&#34;jakarta-rest-as-a-configuration-system&#34;&gt;Jakarta REST as a Configuration System?!&lt;/h2&gt;
&lt;p&gt;Hear me out.&lt;/p&gt;
&lt;p&gt;First, I&amp;rsquo;m not &lt;em&gt;actually&lt;/em&gt; proposing that if you want a configuration
framework in your Java program you should grab a Jakarta REST
implementation and go to town.&lt;/p&gt;
&lt;p&gt;But I &lt;em&gt;am&lt;/em&gt; looking at it as primarily a &lt;em&gt;Java&lt;/em&gt; framework, and not as
something that is web-oriented.  After all, one of its founding goals
was to make it easy to use plain old Java objects (POJOs) to model
representational state transfers.  Who really cares if there is a
network involved or not?&lt;/p&gt;
&lt;h2 id=&#34;the-foundation&#34;&gt;The Foundation&lt;/h2&gt;
&lt;p&gt;Jakarta REST is built atop &lt;em&gt;resource classes&lt;/em&gt;.  While you should of
course consult &lt;a href=&#34;https://jakarta.ee/specifications/restful-ws/3.0/jakarta-restful-ws-spec-3.0.html#resource-classes&#34;&gt;the
specification&lt;/a&gt;
for the official definition of resource classes (and anything else I&amp;rsquo;m
going to wave my hands about in this article), the general gist is: a
resource class is a POJO class with some specifically shaped methods
in it, and annotated in a particular way.&lt;/p&gt;
&lt;p&gt;For retrieval purposes (&lt;code&gt;GET&lt;/code&gt;), which is all I&amp;rsquo;m interested in,
methods that do retrievals obviously need to have a return type.  The
return type can be Jakarta-REST-specific
(&lt;a href=&#34;https://jakarta.ee/specifications/restful-ws/3.0/apidocs/jakarta/ws/rs/core/response&#34;&gt;&lt;code&gt;Response&lt;/code&gt;&lt;/a&gt;),
or can be a POJO designed by the resource class designer.&lt;/p&gt;
&lt;p&gt;The annotations on resource classes and their methods help them
declare what &lt;em&gt;paths&lt;/em&gt; they respond to, and what types of objects those
methods supply in response.&lt;/p&gt;
&lt;p&gt;When you put this all together, you have a subsystem that receives a
typed path, finds a relevant supplier (a resource method), caches that
fact, and then uses that supplier to serve up an &lt;code&gt;Object&lt;/code&gt; of some kind
that corresponds to that path (and other qualifiers).&lt;/p&gt;
&lt;h2 id=&#34;configuration-concerns&#34;&gt;Configuration Concerns&lt;/h2&gt;
&lt;p&gt;When you look at Jakarta REST this way, it starts to look an awful lot
like &lt;a href=&#34;https://ljnelson.github.io/blog/java-configuration-jndi-and-naming-operations/&#34;&gt;some of the JNDI concepts I&amp;rsquo;ve written about previously&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In both cases there is a lookup operation, with name-like structures
identifying the thing to retrieve.  In both cases (although in JNDI
it&amp;rsquo;s a pain in the neck) you can qualify your lookup.  In both cases
an &lt;em&gt;application assembler&lt;/em&gt; can declare explicitly how bundles of
components should be combined into an application in such a way that
naming conflicts do not occur.  In both cases, &lt;em&gt;how&lt;/em&gt; a resulting
&lt;code&gt;Object&lt;/code&gt; is put together, or found, or synthesized, is completely
transparent to the caller and is deliberately unspecified.&lt;/p&gt;
&lt;p&gt;Jakarta REST also features a wealth of additional qualifiers that ride
along with every request.  You have the path, of course, but you also
have headers (key/value pairs), MIME types, and request-level content
negotiation strategies.  If you look at these coarsely enough, they&amp;rsquo;re
just qualifiers further picking out the &lt;code&gt;Object&lt;/code&gt; that is being
requested.&lt;/p&gt;
&lt;p&gt;One of the nice things about the lookup request format that Jakarta
REST uses is that in a &lt;code&gt;path/with/many/components&lt;/code&gt; there is no
presumption that each component in the path designates a retrievable
resource.  (JNDI, by contrast, basically requires that a &lt;code&gt;Context&lt;/code&gt;
exist at each juncture.)  This allows for sparse graphs of resources,
dynamic subresources, and all sorts of other interesting bits that end
up being directly relevant to configuration systems.&lt;/p&gt;
&lt;p&gt;Another nice thing about the lookup request format is that the
incoming name-like structure (the request) consists not just of the
name-like thing (the path) plus its qualifiers (the headers and matrix
parameters and everything else) but also the &lt;em&gt;type&lt;/em&gt; of the object
being requested (expressed as a MIME type).  In my &lt;a href=&#34;https://ljnelson.github.io/blog/java-configuration-jndi-and-naming-operations/&#34;&gt;earlier JNDI
article&lt;/a&gt;, I noted that configuration systems involve a &lt;em&gt;typed path&lt;/em&gt; at the
heart of configuration lookup.  JNDI sort of lets you get there, but
it is awful and clunky to do.  Jakarta REST makes it reasonably easy:
by the time a resource method gets invoked, you know that MIME type
matching has already occurred according to a well-specified algorithm,
so you know that the resource method in question is equipped to
service the request.&lt;/p&gt;
&lt;h2 id=&#34;disambiguation&#34;&gt;Disambiguation&lt;/h2&gt;
&lt;p&gt;Thankfully, the designers of Jakarta REST (well, JAX-RS, in this case)
also realized the namespace issues that always show up when you talk
about someone assembling components together into an application, and
provided for their solution.&lt;/p&gt;
&lt;p&gt;In JNDI, namespace issues are somewhat moot, because names are always
relative to a &lt;code&gt;Context&lt;/code&gt;: there&amp;rsquo;s no such thing as an absolute name.
The same is not true in Jakarta REST, but the application assembler
can explicitly designate an &lt;code&gt;Application&lt;/code&gt; implementation that says for
certain which Java classes are to be considered resource classes, and
which are not.  This allows two resource methods, for example, from
two different sources, annotated with the same &lt;code&gt;@Path&lt;/code&gt; annotation, to
coexist: the application assembler can choose just one, can wrap the
other, or any of a variety of other strategies at assembly time to
resolve the ambiguity.&lt;/p&gt;
&lt;p&gt;(It&amp;rsquo;s worth noting that no Java-centric configuration system that I&amp;rsquo;m
aware of lets you do this fundamental disambiguation operation at
assembly time.  That&amp;rsquo;s really odd.)&lt;/p&gt;
&lt;h2 id=&#34;suitability&#34;&gt;Suitability&lt;/h2&gt;
&lt;p&gt;Probably the most interesting feature of Jakarta REST when looked at
through a Java-centric configuration lens is its built-in notion of
suitability.&lt;/p&gt;
&lt;p&gt;A resource method is more or less suitable for a given request as
specified by an &lt;a href=&#34;https://jakarta.ee/specifications/restful-ws/3.0/jakarta-restful-ws-spec-3.0.html#mapping_requests_to_java_methods&#34;&gt;exceedingly well-defined
algorithm&lt;/a&gt;.
For my purposes, the exact steps of the algorithm are unimportant.
The fact that it exists and is defined in terms of &lt;em&gt;application-level&lt;/em&gt;
concerns, rather than &lt;em&gt;component-level&lt;/em&gt; concerns is what is important.
If this algorithm completes and there are somehow still two or more
candidate resource methods for a given request, then an error is
thrown.  This means that resource method selection is &lt;em&gt;deterministic&lt;/em&gt;:
if you supply the same inputs, you get the same outputs every time.&lt;/p&gt;
&lt;p&gt;Recognizing the difference between application-level concerns and
component-level concerns is critical for this kind of determinism,
because components are often developed in isolation from one another,
so sharing things like namespaces and numberspaces and pathspaces and
all the rest can be difficult.  So, for example, defining the matching
algorithm in terms of a global set of MIME types means that there can
be no name clashes between types: &lt;code&gt;application/octet-stream&lt;/code&gt; means
what it means, regardless of which component uses it.&lt;/p&gt;
&lt;p&gt;Contrast this with another popular but extraordinarily misguided
strategy of labeling some component somewhere with a numeric priority
and believing erroneously that you have somehow solved the ambiguity
problem.  Instead, you&amp;rsquo;ve just punted it: If component &lt;em&gt;A&lt;/em&gt; and
component &lt;em&gt;B&lt;/em&gt; are developed in isolation, and both have independently
decided to declare that they are of priority &lt;code&gt;10&lt;/code&gt;, that is still a
problem the application assembler has to solve, but unless there is
yet &lt;em&gt;another&lt;/em&gt; mechanism for her to disambiguiate &lt;em&gt;this&lt;/em&gt; ambiguity, it
can lead to a non-deterministic state of affairs.  We see this, &lt;a href=&#34;https://lairdnelson.wordpress.com/2021/10/14/some-of-the-things-i-dont-like-about-microprofile-config/&#34;&gt;as
I&amp;rsquo;ve noted earlier, in MicroProfile
Config&lt;/a&gt;.
(Interestingly, Jakarta REST &lt;a href=&#34;https://jakarta.ee/specifications/restful-ws/3.0/jakarta-restful-ws-spec-3.0.html#provider_priorities&#34;&gt;&lt;em&gt;did&lt;/em&gt; walk into this trap in terms of
providers&lt;/a&gt;
and other accessory entities, but at least they give the application
assembler a welcome &amp;ldquo;out&amp;rdquo; since she can always write an &lt;code&gt;Application&lt;/code&gt;
class to make things more explicit.)&lt;/p&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Jakarta REST is a specification for web services, yes, but it is also
a specification for acquiring Java &lt;code&gt;Object&lt;/code&gt;s given path-like requests,
where the potential suppliers of such &lt;code&gt;Object&lt;/code&gt;s can be more or less
suitable for any given request.  This lines up pretty well with the
requirements of a Java-centric configuration system.  There are
lessons to be learned here that can be applied to the design of a
&amp;ldquo;real&amp;rdquo; Java-centric configuration system.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java Configuration: JNDI and Naming Operations</title>
      <link>https://ljnelson.github.io/blog/java-configuration-jndi-and-naming-operations/</link>
      <pubDate>Thu, 30 Dec 2021 16:22:37 -0800</pubDate>
      <author>ljnelson@gmail.com (Laird Nelson)</author>
      <guid>https://ljnelson.github.io/blog/java-configuration-jndi-and-naming-operations/</guid>
      <description>&lt;div&gt;
  &lt;h2 id=&#34;table-of-contents&#34;&gt;Table Of Contents&lt;/h2&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#background-and-rationale&#34;&gt;Background and Rationale&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#whats-in-a-naming-service-name&#34;&gt;What&amp;rsquo;s In A (Naming Service) Name?&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#the-object-management-group-naming-service-specification&#34;&gt;The Object Management Group Naming Service Specification&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#jndi&#34;&gt;JNDI&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#bootstrapping&#34;&gt;Bootstrapping&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#retrieval-operations&#34;&gt;Retrieval Operations&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#binding-operations&#34;&gt;Binding Operations&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#name-to-object-bindings&#34;&gt;Name-to-&lt;code&gt;Object&lt;/code&gt; Bindings&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#synthesizing-operations&#34;&gt;Synthesizing Operations&lt;/a&gt;
          &lt;ul&gt;
            &lt;li&gt;&lt;a href=&#34;#objectfactory&#34;&gt;&lt;code&gt;ObjectFactory&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#event-operations&#34;&gt;Event Operations&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#putting-it-all-together&#34;&gt;Putting It All Together&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#jndi-flaws&#34;&gt;JNDI Flaws&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#no-generics&#34;&gt;No Generics&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#binding-and-lookup-services-colocated&#34;&gt;Binding and Lookup Services Colocated&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#vague-qualifiers&#34;&gt;Vague Qualifiers&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#too-many-checked-exceptions&#34;&gt;Too Many Checked Exceptions&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#cant-use-class-or-type-as-a-selector&#34;&gt;Can&amp;rsquo;t Use &lt;code&gt;Class&lt;/code&gt; or &lt;code&gt;Type&lt;/code&gt; as a Selector&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#strange-service-provider-location-machinery&#34;&gt;Strange Service Provider Location Machinery&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#too-much-hierarchy&#34;&gt;Too Much Hierarchy&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#conclusion&#34;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#whats-next&#34;&gt;What&amp;rsquo;s Next&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;/div&gt;

&lt;h2 id=&#34;background-and-rationale&#34;&gt;Background and Rationale&lt;/h2&gt;
&lt;p&gt;I&amp;rsquo;ve written
&lt;a href=&#34;https://lairdnelson.wordpress.com/2021/11/07/configuration-and-dependency-acquisition/&#34;&gt;previously&lt;/a&gt;
about how Java configuration systems, boiled down to their essence,
are simply systems for loading Java objects that are described in a
particular way, usually by some kind of name (along with
&lt;a href=&#34;https://lairdnelson.wordpress.com/2021/12/07/qualifiers-and-configuration-coordinates-in-configuration/&#34;&gt;qualifiers&lt;/a&gt;),
and that such systems have absolutely &lt;a href=&#34;https://lairdnelson.wordpress.com/2021/11/07/configuration-and-dependency-acquisition/&#34;&gt;nothing to do with dependency
injection&lt;/a&gt;
or object binding or all the rest of the shiny but irrelevant things
people like to get excited about in this space.&lt;/p&gt;
&lt;p&gt;These ideas are not new.  In the Java enterprise world, they first
showed up in a systematic way in the &lt;a href=&#34;https://docs.oracle.com/en/java/javase/17/docs/api/java.naming/module-summary.html&#34;&gt;Java Naming and Directory
Interface (JNDI)
API&lt;/a&gt;.
This API, in turn, is a slight modernization, and idiomatic Java
translation, of the &lt;a href=&#34;https://www.omg.org/spec/NAM/1.3/PDF&#34;&gt;Object Management Group&amp;rsquo;s Naming Service
Specification&lt;/a&gt;, which quietly
stagnated sometime in 2004.&lt;/p&gt;
&lt;p&gt;Somewhere along the line, JNDI got (wrongly) pigeonholed as just a
way to access LDAP servers.  I&amp;rsquo;m going to ignore that entire side of
things (the &amp;ldquo;directory&amp;rdquo; part), because that&amp;rsquo;s not what JNDI primarily
is at all.&lt;/p&gt;
&lt;p&gt;Then it got demonized because of the &lt;code&gt;java:&lt;/code&gt; URL scheme and the
&lt;code&gt;comp/env&lt;/code&gt; naming prefix mandated by the Java EE Platform
Specification to identify a component&amp;rsquo;s environment, but, as we&amp;rsquo;ll
see, the concept underlying this prefix is critical, regardless of how
clunky the actual implementation turned out to be.&lt;/p&gt;
&lt;p&gt;Now JNDI is routinely rejected more simply because of its age than
because of any technical limitations it might have.  Most people have
no idea what it can do.  Having said that, it most certainly does show
its age, and not in a good way.&lt;/p&gt;
&lt;p&gt;So why &lt;em&gt;would&lt;/em&gt; we look at all this?  Because to this day it is the
only Java-related configuration-like system that has appropriately
considered most, if not all, the concerns that arise when you talk
about loading Java objects that are qualified in some way into a
class—the very heart of Java-centric configuration use cases:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It accounts for name collisions.&lt;/li&gt;
&lt;li&gt;It has symbolic links.&lt;/li&gt;
&lt;li&gt;It allows for user-supplied name resolution mechanisms.&lt;/li&gt;
&lt;li&gt;It allows for user-supplied namespaces.&lt;/li&gt;
&lt;li&gt;It permits qualifiers to help describe a lookup.&lt;/li&gt;
&lt;li&gt;It does not mandate an object binding strategy.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It&amp;rsquo;s somewhat bizarre to note that the Java-centric configuration
frameworks currently &lt;em&gt;en vogue&lt;/em&gt; are so comparatively deficient:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;MicroProfile Config certainly has not considered these concerns.
(As I&amp;rsquo;ve &lt;a href=&#34;https://lairdnelson.wordpress.com/2021/10/14/some-of-the-things-i-dont-like-about-microprofile-config/&#34;&gt;written
before&lt;/a&gt;,
it is non-deterministic and subject to namespace clashes.)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Lightbend&amp;rsquo;s TypeSafe Config has not considered these concerns.
(Names are considered to be absolute.)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Spring has not considered these concerns.  (Names are considered to
be absolute and configured objects are presumed to &amp;ldquo;belong&amp;rdquo; to the
Spring ecosystem.)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Jakarta Config is stumbling backwards into these concerns without
realizing they are valid concerns, and is repeating the egregious
mistakes of MicroProfile Config before it.  (It is non-deterministic
and subject to namespace clashes and is focusing its standardization
efforts in irrelevant places.)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I&amp;rsquo;m sure there are others.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;What if we could extract the age-old lookup-and-namespace-related
concerns that JNDI addresses and re-express them with a modern API?&lt;/strong&gt;
That would make for a pretty decent Java-centric configuration API.&lt;/p&gt;
&lt;p&gt;To catch a glimpse of these concerns and how they are addressed within
JNDI requires a little bit of squinting.  The JNDI API itself is old
and outdated by today&amp;rsquo;s standards.  It predates generics, for one
thing, and &lt;a href=&#34;https://mail.openjdk.java.net/pipermail/core-libs-dev/2021-August/080696.html&#34;&gt;attempts to modernize it, regardless of how trivial, have
been gently and officially
rebuffed&lt;/a&gt;.
For another, it predates the &lt;a href=&#34;&#34;&gt;&lt;code&gt;java.util.ServiceLoader&lt;/code&gt;&lt;/a&gt; convention
of discovering service providers at startup.  It is, in short, a pain
in the neck to work with.&lt;/p&gt;
&lt;p&gt;Getting past these anachronisms and others like them can be a little
tricky, but the journey is worth it.&lt;/p&gt;
&lt;h2 id=&#34;whats-in-a-naming-service-name&#34;&gt;What&amp;rsquo;s In A (Naming Service) Name?&lt;/h2&gt;
&lt;p&gt;Let&amp;rsquo;s talk about what a naming service does, and why the terms even
exist, and, as a result, why no one ever thinks of &amp;ldquo;naming service&amp;rdquo; in
the same breath as &amp;ldquo;configuration&amp;rdquo; (but maybe they should).&lt;/p&gt;
&lt;p&gt;First, we&amp;rsquo;ll talk about JNDI&amp;rsquo;s precursor, the &lt;a href=&#34;https://www.omg.org/spec/NAM/1.3/PDF&#34;&gt;Object Management
Group&amp;rsquo;s Naming Service
Specification&lt;/a&gt;.  I know:
CORBA—but bear with me.&lt;/p&gt;
&lt;h3 id=&#34;the-object-management-group-naming-service-specification&#34;&gt;The Object Management Group Naming Service Specification&lt;/h3&gt;
&lt;p&gt;Let&amp;rsquo;s revisit the 1990s for a moment.  &lt;a href=&#34;https://knowyourmeme.com/memes/how-do-you-do-fellow-kids&#34;&gt;How do you do, fellow
kids?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Back in CORBA&amp;rsquo;s day, you could park distributed objects on one
machine, and use another machine to look them up, and the calling
program might be written in an entirely different language from the
serving program.  The sub-programs doing the actual retrieval and
serving were known as ORBs: object request brokers.  As you might
imagine, an object request broker turns a simple local request for a
particular object into a distributed request for that object, and
answers such remote requests as well.&lt;/p&gt;
&lt;p&gt;Because CORBA is cross-language, this meant that each ORB had to be
able to park an object under some kind of location that any requestor
could specify in some way, regardless of the languages involved.  All
languages have strings, and CORBA had ironed out the various language-
and machine-related discrepancies among strings, so the way you
identified the object you wanted to retrieve from some other ORB was
to effectively just name it.  So a &lt;em&gt;naming service&lt;/em&gt;, then, is
something that, when given a string-typed, address-like name of some
kind, gives you back an object bound under that name, suitable for
immediate use in the calling language.  (Usually there was a hazy
presumption that something remote-ish had occurred, e.g. you had
retrieved an object over the network from some other machine
somewhere.  This was because so-called distributed objects were cool.
Now we know better, but the (mostly valid) concepts involved apply
even locally, as we&amp;rsquo;ll see.)&lt;/p&gt;
&lt;p&gt;(More importantly for configuration-related purposes, a name&amp;rsquo;s sole
function, really, is to help distinguish one typed object from another
object bearing the same type.)&lt;/p&gt;
&lt;p&gt;Getting ORBs from different vendors to cooperate was tough, so there
were a lot of specifications that ended up being written by the
&lt;a href=&#34;https://www.omg.org/&#34;&gt;Object Management Group&lt;/a&gt;.  One of them was a
specification governing hierarchical naming semantics, named,
appropriately enough, the &lt;a href=&#34;https://www.omg.org/spec/NAM/1.3/PDF&#34;&gt;Naming Service
Specification&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;There&amp;rsquo;s nothing that says, inherently, that a naming service has to be
hierarchical.  But hierarchies can be convenient, and the Naming
Service Specification decided to formally specify tree-based naming
semantics instead of flat ones.  The root of a naming service tree is
a &lt;em&gt;context&lt;/em&gt;; its nodes are &lt;em&gt;objects&lt;/em&gt;; its branches are &lt;em&gt;names&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;(A context, of course, is also a kind of object, and again, while
specifying the notion of a child context is not required, that&amp;rsquo;s how
the Naming Service Specification decided to do it.)&lt;/p&gt;
&lt;p&gt;(Some of this hierarchical stuff was due to the inherent chattiness of
CORBA itself: you didn&amp;rsquo;t want to traverse deep graphs with remote
calls for each traversal operation!  Better to grab a context and use
it directly to get its stuff.)&lt;/p&gt;
&lt;p&gt;Among other things, all of this means that, in the Naming Service
Specification, any given name is always relative to a parent context.
There are no absolute names.  If I give you a name, you don&amp;rsquo;t know
what it means or designates (in the absence of other information).
But if I tell you that it&amp;rsquo;s relative to a particular context, then you
have the tools to be able to &lt;em&gt;resolve&lt;/em&gt; the name against that context
and find the object it points to.  A context turns out to be a
namespace (among other things).&lt;/p&gt;
&lt;p&gt;(In the world of name-based configuration this concept is absolutely
critical.  It is ignored by all major Java-centric configuration
frameworks for no good reason that I can see.)&lt;/p&gt;
&lt;p&gt;In the Naming Service Specification, names have structure.  A sequence
of &lt;em&gt;components&lt;/em&gt; within a name forms a &lt;em&gt;compound name&lt;/em&gt;.  Its individual
components are also known as &lt;em&gt;simple names&lt;/em&gt;.  Finally, if you have a
compound name with two components (simple names), there is also one
context involved: the one that the first component desginates, and to
which the second component is relative. (To belabor an earlier point,
note that the first component (simple name) is relative to some
context but in this example I haven&amp;rsquo;t told you what it is, so,
standing on its own, this hypothetical compound name is rather
useless.)&lt;/p&gt;
&lt;p&gt;The Naming Service Specification also gestures feebly at another type
of identifier that is sort of part of names: &lt;em&gt;kind&lt;/em&gt;.  It reads, in
part:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The &lt;strong&gt;kind&lt;/strong&gt; attribute adds descriptive power to names in a
syntax-independent way.  Examples of the value of the &lt;strong&gt;kind&lt;/strong&gt;
attribute include &lt;em&gt;c_source&lt;/em&gt;, &lt;em&gt;object_code&lt;/em&gt;, &lt;em&gt;executable&lt;/em&gt;,
&lt;em&gt;postscript&lt;/em&gt;, or “ ”. The naming system does not interpret, assign, or
manage these values in any way. Higher levels of software may make
policies about the use and management of these values. This feature
addresses the needs of applications that use syntactic naming
conventions to distinguish related objects. For example Unix uses
suffixes such as &lt;strong&gt;.c&lt;/strong&gt; and &lt;strong&gt;.o&lt;/strong&gt;. Applications (such as the C
compiler) depend on these syntactic convention to make name
transformations (for example, to transform &lt;strong&gt;foo.c&lt;/strong&gt; to &lt;strong&gt;foo.o&lt;/strong&gt;).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(This reads as a kind of primitive precursor to MIME types.  It also
demonstrates, inadvertently, that any system that uses a &amp;ldquo;name&amp;rdquo; to
look something up eventually realizes that it &lt;em&gt;must&lt;/em&gt; use
&lt;a href=&#34;https://lairdnelson.wordpress.com/2021/12/07/qualifiers-and-configuration-coordinates-in-configuration/&#34;&gt;&lt;em&gt;qualifiers&lt;/em&gt;&lt;/a&gt;
to look something up instead.  JAX-RS matrix parameters, and HTTP
headers, are other examples of this sort of thing.  There&amp;rsquo;s plenty
more to say about this, but not here.)&lt;/p&gt;
&lt;h2 id=&#34;jndi&#34;&gt;JNDI&lt;/h2&gt;
&lt;p&gt;JNDI&amp;rsquo;s naming services are a very straightforward translation of the
language-independent terminology of the Naming Service Specification
into relatively idiomatic Java terms.&lt;/p&gt;
&lt;p&gt;JNDI, like the Naming Service Specification, has a &lt;code&gt;Context&lt;/code&gt;, which,
like its namesake, is a locus of
&lt;a href=&#34;https://docs.oracle.com/en/java/javase/17/docs/api/java.naming/javax/naming/Name.html&#34;&gt;&lt;code&gt;Name&lt;/code&gt;s&lt;/a&gt;
that designate &lt;code&gt;Object&lt;/code&gt;s (including other &lt;code&gt;Context&lt;/code&gt;s).  (A &lt;code&gt;Context&lt;/code&gt;
belongs to a &lt;em&gt;naming system&lt;/em&gt;, which is a conceptual entity seemingly
introduced by the JNDI specification and not really present in the
Naming Service Specification.)&lt;/p&gt;
&lt;p&gt;JNDI&amp;rsquo;s
&lt;a href=&#34;https://docs.oracle.com/en/java/javase/17/docs/api/java.naming/javax/naming/Name.html&#34;&gt;&lt;code&gt;Name&lt;/code&gt;s&lt;/a&gt;
are like those of the Naming Service Specification, but do not
explicitly include the concept of &lt;em&gt;simple&lt;/em&gt; names.  Instead, a JNDI
name is always either a &lt;a href=&#34;https://docs.oracle.com/en/java/javase/17/docs/api/java.naming/javax/naming/CompoundName.html&#34;&gt;compound
name&lt;/a&gt;,
even if it has only one component, or a &lt;a href=&#34;https://docs.oracle.com/en/java/javase/17/docs/api/java.naming/javax/naming/CompositeName.html&#34;&gt;&lt;em&gt;composite
name&lt;/em&gt;&lt;/a&gt;,
a term not mentioned in the Naming Service Specification.  (Composite
names were added in a JNDI specification revision, and allow a single
name to automatically span actual naming systems, with sophisticated
parsing semantics.)  Within any given naming system, hierarchical or
flat, you&amp;rsquo;re always working with compound names.&lt;/p&gt;
&lt;p&gt;Like the Naming Service Specification, any given JNDI
&lt;a href=&#34;https://docs.oracle.com/en/java/javase/17/docs/api/java.naming/javax/naming/Name.html&#34;&gt;&lt;code&gt;Name&lt;/code&gt;&lt;/a&gt;
is always relative to a parent &lt;code&gt;Context&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;bootstrapping&#34;&gt;Bootstrapping&lt;/h3&gt;
&lt;p&gt;JNDI allows an implementor to bootstrap itself.  This is fairly
unique, even today.&lt;/p&gt;
&lt;p&gt;Specifically, the
&lt;a href=&#34;https://docs.oracle.com/en/java/javase/17/docs/api/java.naming/javax/naming/InitialContext.html&#34;&gt;&lt;code&gt;InitialContext&lt;/code&gt;&lt;/a&gt;
class is just a &lt;code&gt;Context&lt;/code&gt; implementation that finds a &amp;ldquo;real&amp;rdquo; &lt;code&gt;Context&lt;/code&gt;
implementation to use, and then delegates all operations to it.  The
JNDI bootstrap mechanism, which predates the &lt;code&gt;java.util.ServiceLoader&lt;/code&gt;
service provider approach but which seems to have served as its
inspiration, allows custom &lt;code&gt;InitialContext&lt;/code&gt; implementations to be
supplied from outside of the framework.&lt;/p&gt;
&lt;p&gt;This means, among other things, the &lt;code&gt;Context&lt;/code&gt; to which primordial
&lt;code&gt;Name&lt;/code&gt;s are relative is highly customizable, even by end users.&lt;/p&gt;
&lt;p&gt;In today&amp;rsquo;s Java world, someone would probably have introduced
(needlessly) a builder-style object, or a whole scaffolding framework
for finding the root &lt;code&gt;Context&lt;/code&gt;.  In JNDI, you just call &lt;code&gt;new InitialContext()&lt;/code&gt; and you&amp;rsquo;re done, as it should be.&lt;/p&gt;
&lt;h3 id=&#34;retrieval-operations&#34;&gt;Retrieval Operations&lt;/h3&gt;
&lt;p&gt;From the looking-things-up perspective, that&amp;rsquo;s about it.  Get your
hands on a
&lt;a href=&#34;https://docs.oracle.com/en/java/javase/17/docs/api/java.naming/javax/naming/Context.html&#34;&gt;&lt;code&gt;Context&lt;/code&gt;&lt;/a&gt;,
&lt;a href=&#34;https://docs.oracle.com/en/java/javase/17/docs/api/java.naming/javax/naming/Context.html#lookup(javax.naming.Name)&#34;&gt;ask it for an &lt;code&gt;Object&lt;/code&gt; under a particular
&lt;code&gt;Name&lt;/code&gt;&lt;/a&gt;,
and make use of the resulting &lt;code&gt;Object&lt;/code&gt;.  Where the &lt;code&gt;Object&lt;/code&gt; came from,
how it was bound, whether it was synthesized out of other &lt;code&gt;Object&lt;/code&gt;s,
whether various kinds of links and redirects were followed, whether
the &lt;code&gt;Object&lt;/code&gt; fronts some other kind of system—none of these things are
your concern.  You named an &lt;code&gt;Object&lt;/code&gt;, you resolved that name against a
&lt;code&gt;Context&lt;/code&gt;, and you took delivery of that &lt;code&gt;Object&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Of particular note, you probably also cast that &lt;code&gt;Object&lt;/code&gt; to a type you
were expecting.  More on that later.  Peeking ahead for a moment, a
name always has a conceptual type that the caller, for the most part,
is expecting.&lt;/p&gt;
&lt;h3 id=&#34;binding-operations&#34;&gt;Binding Operations&lt;/h3&gt;
&lt;p&gt;Since JNDI emerged from the CORBA world and was a faithful carryover
of the Naming Service Specification, it also handled the &amp;ldquo;writing
side&amp;rdquo; of naming services.  Placing an &lt;code&gt;Object&lt;/code&gt; under a &lt;code&gt;Name&lt;/code&gt; in JNDI
is known as &lt;em&gt;binding&lt;/em&gt;.  For my purposes, I&amp;rsquo;ll be ignoring all binding
operations.  Java EE, in fact, one of the earliest consumers of JNDI,
required that &lt;code&gt;Context&lt;/code&gt;s exposed to the end user be read-only, and
it&amp;rsquo;s a regrettable fact (in my opinion) that the mutating operations
of JNDI were not split into their own sub-specification.&lt;/p&gt;
&lt;h3 id=&#34;name-to-object-bindings&#34;&gt;Name-to-&lt;code&gt;Object&lt;/code&gt; Bindings&lt;/h3&gt;
&lt;p&gt;For ordinary use cases, a &lt;code&gt;Name&lt;/code&gt; in JNDI is always conceptually bound
to some kind of &lt;code&gt;Object&lt;/code&gt;.  This means that a &lt;code&gt;Name&lt;/code&gt;, regardless of how
many components it might have, also has an effective (Java) type,
namely, that of the &lt;code&gt;Object&lt;/code&gt; that it references.&lt;/p&gt;
&lt;p&gt;JNDI has a few clunky introspective APIs for listing bindings, but for
my purposes I&amp;rsquo;m going to ignore them, since in configuration use cases
you already know the name of the thing you&amp;rsquo;re looking up.  What&amp;rsquo;s
mainly important here is that a &lt;code&gt;Name&lt;/code&gt;, when resolved against a
&lt;code&gt;Context&lt;/code&gt;, is effectively typed by a Java class.&lt;/p&gt;
&lt;h3 id=&#34;synthesizing-operations&#34;&gt;Synthesizing Operations&lt;/h3&gt;
&lt;p&gt;JNDI has a facility, not found in the Naming Service Specification,
that permits some other Java object to synthesize a Java object out of
&amp;ldquo;raw materials&amp;rdquo;, any of which may be bound in a tree rooted at any
&lt;code&gt;Context&lt;/code&gt;.  This object doing the synthesizing is called an
&lt;a href=&#34;https://docs.oracle.com/en/java/javase/17/docs/api/java.naming/javax/naming/spi/ObjectFactory.html&#34;&gt;&lt;code&gt;ObjectFactory&lt;/code&gt;&lt;/a&gt;.
A JNDI implementation itself can supply &lt;code&gt;ObjectFactory&lt;/code&gt; instances,
but, more importantly for this article&amp;rsquo;s purposes, so can users and
component providers.&lt;/p&gt;
&lt;p&gt;This sounds complicated but is actually fairly simple.&lt;/p&gt;
&lt;p&gt;Recall that when you look something up in a JNDI tree rooted under a
&lt;code&gt;Context&lt;/code&gt;, you are blissfully unaware of the name resolution process
(how the &lt;code&gt;Object&lt;/code&gt; that is eventually delivered to you came to exist).
Was it put together out of other things?  Was it created out of
nothing?  Was it loaded from disk?  Served over the network?  You
don&amp;rsquo;t know and you don&amp;rsquo;t care.&lt;/p&gt;
&lt;p&gt;For certain cases, name resolution is absurdly simple: someone
explicitly bound a textual string into a &lt;code&gt;Context&lt;/code&gt; under, say, the
name &amp;ldquo;&lt;code&gt;hoopy&lt;/code&gt;&amp;rdquo;; you asked for the &lt;code&gt;Object&lt;/code&gt; bound under &amp;ldquo;&lt;code&gt;hoopy&lt;/code&gt;&amp;rdquo;; and
lo and behold you got back that very string—perhaps &amp;ldquo;&lt;code&gt;frood&lt;/code&gt;&amp;quot;—as a
Java &lt;code&gt;String&lt;/code&gt; object.  Nothing fancy here.&lt;/p&gt;
&lt;h4 id=&#34;objectfactory&#34;&gt;&lt;code&gt;ObjectFactory&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;In other cases, an
&lt;a href=&#34;https://docs.oracle.com/en/java/javase/17/docs/api/java.naming/javax/naming/spi/ObjectFactory.html&#34;&gt;&lt;code&gt;ObjectFactory&lt;/code&gt;&lt;/a&gt;
gets involved.  This happens because the &lt;a href=&#34;https://docs.oracle.com/en/java/javase/17/docs/api/java.naming/javax/naming/Context.html#lookup(javax.naming.Name)&#34;&gt;&lt;code&gt;Context::lookup&lt;/code&gt;
operation&lt;/a&gt;
delegates, in all implementations that I&amp;rsquo;m aware of, and perhaps
explicitly stated somewhere, to a call to the
&lt;a href=&#34;https://docs.oracle.com/en/java/javase/17/docs/api/java.naming/javax/naming/spi/NamingManager.html#getObjectInstance(java.lang.Object,javax.naming.Name,javax.naming.Context,java.util.Hashtable)&#34;&gt;&lt;code&gt;NamingManager::getObjectInstance&lt;/code&gt;&lt;/a&gt;
method, which pulls in &lt;code&gt;ObjectFactory&lt;/code&gt; instances to actually perform
the creation (or retrieval, or synthesis, or whatever) of a Java
&lt;code&gt;Object&lt;/code&gt; for a given &lt;code&gt;Name&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So backing up from the minutiae for a moment, depending on what
&lt;code&gt;ObjectFactory&lt;/code&gt; instances are on the classpath and properly
designated, a JNDI implementation may synthesize &lt;code&gt;Object&lt;/code&gt;s out of thin
air as if they were bound explicitly to various &lt;code&gt;Name&lt;/code&gt;s.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ObjectFactory&lt;/code&gt; instances and explicit binding can work together,
too.  An administrator can bind a &lt;a href=&#34;&#34;&gt;&lt;code&gt;Reference&lt;/code&gt;&lt;/a&gt; into a JNDI
implementation that explicitly names the &lt;code&gt;ObjectFactory&lt;/code&gt; to use to
perform the actual name resolution.&lt;/p&gt;
&lt;h5 id=&#34;url-context-factory&#34;&gt;URL Context Factory&lt;/h5&gt;
&lt;p&gt;One kind of &lt;code&gt;ObjectFactory&lt;/code&gt; is one that plays the role of a &lt;em&gt;URL
context factory&lt;/em&gt;.  These kinds of &lt;code&gt;ObjectFactory&lt;/code&gt; implementations can
create &lt;code&gt;Context&lt;/code&gt;s to represent particular URL schemes, such as, most
infamously, &lt;code&gt;java:&lt;/code&gt;, which is at the heart of the Java EE (and now
Jakarta EE) specifications.&lt;/p&gt;
&lt;p&gt;The notorious &lt;code&gt;java:comp/env&lt;/code&gt; &amp;ldquo;prefix&amp;rdquo; is, more specifically, a URL
whose semantics are strictly defined by the Java EE (now Jakarta EE)
Platform Specification.  &lt;code&gt;java:&lt;/code&gt; causes a URL context factory
specified by the Platform Specification to come into the picture, and
&lt;code&gt;comp/env&lt;/code&gt; is a compound name, relative to the root &lt;code&gt;Context&lt;/code&gt; created
by the URL context factory, denoting, by definition, a &lt;code&gt;Context&lt;/code&gt; with
very specific semantics.  One of its specific semantics is very
interesting to configuration systems, because it disambiguates
component namespaces.  That is, if an EJB refers to a &lt;code&gt;Frood&lt;/code&gt; stored
under the name &lt;code&gt;hoopy&lt;/code&gt;, and another EJB refers to a &lt;code&gt;Towel&lt;/code&gt; stored
under the name &lt;code&gt;hoopy&lt;/code&gt;, no conflict can occur, so long as &lt;code&gt;hoopy&lt;/code&gt; is
relative to &lt;code&gt;java:comp/env&lt;/code&gt; in both cases.&lt;/p&gt;
&lt;p&gt;No Java-centric configuration framework that I&amp;rsquo;m aware of other than
JNDI addresses this extremely important concern.&lt;/p&gt;
&lt;h3 id=&#34;event-operations&#34;&gt;Event Operations&lt;/h3&gt;
&lt;p&gt;JNDI features &lt;a href=&#34;https://docs.oracle.com/en/java/javase/17/docs/api/java.naming/javax/naming/event/EventContext.html&#34;&gt;events that can be
fired&lt;/a&gt;
when a bound object changes, or when an object has been added or
removed.&lt;/p&gt;
&lt;h2 id=&#34;putting-it-all-together&#34;&gt;Putting It All Together&lt;/h2&gt;
&lt;p&gt;So backing up to the conceptual level, JNDI provides the ability for
two names to be used by two different components developed in
isolation to refer to two different things, with at least the
&lt;em&gt;possibility&lt;/em&gt; that a name clash will not occur (one component&amp;rsquo;s
&lt;code&gt;java:comp/env&lt;/code&gt; &lt;code&gt;Context&lt;/code&gt; is not the same &lt;code&gt;Context&lt;/code&gt; as another
component&amp;rsquo;s &lt;code&gt;java:comp/env&lt;/code&gt; &lt;code&gt;Context&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;In addition, it allows for user-supplied factories to handle
individual name resolution operations.  There is a defined search
order for discovering such factories.  You supply a name, the system
searches until it finds something that can make &lt;code&gt;Object&lt;/code&gt;s for that
name.&lt;/p&gt;
&lt;p&gt;JNDI properly separates the lookup use cases (ask for an &lt;code&gt;Object&lt;/code&gt; of a
particular type by name; receive it) from the binding and
administration use cases (install an &lt;code&gt;ObjectFactory&lt;/code&gt; that knows how to
make an &lt;code&gt;Object&lt;/code&gt; of a particular type; bind that &lt;code&gt;ObjectFactory&lt;/code&gt; to a
particular name), to such a degree that there could have been two
specifications instead of one.&lt;/p&gt;
&lt;p&gt;Operations such as conversion and object binding are deliberately left
unspecified, as it should be.  That is, any given &lt;code&gt;ObjectFactory&lt;/code&gt; may
do whatever it wishes to come up with an &lt;code&gt;Object&lt;/code&gt; for a given name
resolution request.&lt;/p&gt;
&lt;p&gt;At an abstract level, a compound name is a typed path, whose
intermediate nodes may have known types as well.&lt;/p&gt;
&lt;p&gt;If we strip some of the terminology and API cruft away we can say the
following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In JNDI and configuration systems, there is some kind of root object
to which notional paths are relative.
&lt;ul&gt;
&lt;li&gt;In JNDI this is a &lt;code&gt;Context&lt;/code&gt; and the rootiest of all root
&lt;code&gt;Context&lt;/code&gt;s is an &lt;code&gt;InitialContext&lt;/code&gt;, as the name accurately
reflects.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;In JNDI and configuration systems, you locate an &lt;code&gt;Object&lt;/code&gt; by
supplying that root object with a typed path that designates the
&lt;code&gt;Object&lt;/code&gt; to retrieve.
&lt;ul&gt;
&lt;li&gt;In JNDI this is a &lt;code&gt;CompoundName&lt;/code&gt; supplied to the
&lt;a href=&#34;https://docs.oracle.com/en/java/javase/17/docs/api/java.naming/javax/naming/Context.html#lookup(javax.naming.Name)&#34;&gt;&lt;code&gt;Context::lookup&lt;/code&gt;&lt;/a&gt;
method, and if you need to figure out what the type is, you can
invoke any of several crufty methods to find the relevant
&lt;code&gt;Class&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;In JNDI and configuration systems, some accessory piece of
technology that is registered under that typed path is actually
responsible for making the requested &lt;code&gt;Object&lt;/code&gt; come into existence.
&lt;ul&gt;
&lt;li&gt;In JNDI, this is an &lt;code&gt;ObjectFactory&lt;/code&gt; invoked by way of the
&lt;a href=&#34;https://docs.oracle.com/en/java/javase/17/docs/api/java.naming/javax/naming/spi/NamingManager.html#getObjectInstance(java.lang.Object,javax.naming.Name,javax.naming.Context,java.util.Hashtable)&#34;&gt;&lt;code&gt;NamingManager::getObjectInstance&lt;/code&gt;&lt;/a&gt;
method.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;jndi-flaws&#34;&gt;JNDI Flaws&lt;/h2&gt;
&lt;p&gt;So is JNDI the hipster configuration system that has been hiding in
plain sight?  Yes and no.&lt;/p&gt;
&lt;p&gt;We&amp;rsquo;ve seen that it gets the separation of concerns right, and that its
lookup features are relatively simple, and that it is unique among
configuration systems in understanding the importance of namespaces.
But there are plenty of problems.&lt;/p&gt;
&lt;h3 id=&#34;no-generics&#34;&gt;No Generics&lt;/h3&gt;
&lt;p&gt;First of all, in modern Java, you may not be looking for a &lt;code&gt;List&lt;/code&gt;
under a specific name, but a &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;.  JNDI predates generics,
so you&amp;rsquo;ll have to do a lot of casting when you use this API.&lt;/p&gt;
&lt;h3 id=&#34;binding-and-lookup-services-colocated&#34;&gt;Binding and Lookup Services Colocated&lt;/h3&gt;
&lt;p&gt;Next, a &lt;code&gt;Context&lt;/code&gt; has a rather large number of methods because the
lookup and binding services were combined into one interface.  In
hindsight, this was a mistake.&lt;/p&gt;
&lt;h3 id=&#34;vague-qualifiers&#34;&gt;Vague Qualifiers&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Context&lt;/code&gt; instances have the ability to have &amp;ldquo;environments&amp;rdquo;, which are
&lt;code&gt;Hashtable&lt;/code&gt;s (yes, &lt;code&gt;Hashtable&lt;/code&gt;s; JNDI predates the collections APIs)
but whose purpose is left vague.  Like any specification that features
an untyped bag of named properties, this is usually a sign that some
aspect of the problem domain wasn&amp;rsquo;t really understood too well.&lt;/p&gt;
&lt;p&gt;If you look at it one way, a &lt;code&gt;Context&lt;/code&gt;&amp;rsquo;s environment is really
additional qualifiers qualifying lookups.  For configuration system
purposes, this concept, which I&amp;rsquo;ve argued is necessary, needs to be
tightened up a little bit.&lt;/p&gt;
&lt;h3 id=&#34;too-many-checked-exceptions&#34;&gt;Too Many Checked Exceptions&lt;/h3&gt;
&lt;p&gt;JNDI was created when checked exceptions were all the rage.  This
makes using it in today&amp;rsquo;s Java projects laborious and unpleasant.
Easy use cases, like using a default value in case a bound value is
not present, are quite difficult as a result.&lt;/p&gt;
&lt;h3 id=&#34;cant-use-class-or-type-as-a-selector&#34;&gt;Can&amp;rsquo;t Use &lt;code&gt;Class&lt;/code&gt; or &lt;code&gt;Type&lt;/code&gt; as a Selector&lt;/h3&gt;
&lt;p&gt;The fact that it is a &lt;code&gt;Name&lt;/code&gt;, and not some other kind of key, that is
used to select &lt;code&gt;Object&lt;/code&gt;s is mostly arbitrary and rooted in CORBA&amp;rsquo;s
distributed objects background.  For Java-centric configuration
systems, what matters most of the time is the type of &lt;code&gt;Object&lt;/code&gt; the
caller is seeking.  Names in this use case are secondary and used
mostly to disambiguate, for example, one kind of &lt;code&gt;Frood&lt;/code&gt; from another
kind of &lt;code&gt;Frood&lt;/code&gt; (perhaps the caller wants the &lt;code&gt;hoopy&lt;/code&gt; &lt;code&gt;Frood&lt;/code&gt; and not
the unnamed &lt;code&gt;Frood&lt;/code&gt;).  JNDI requires that there be names for
&lt;em&gt;everything&lt;/em&gt;, even where they are superfluous.&lt;/p&gt;
&lt;h3 id=&#34;strange-service-provider-location-machinery&#34;&gt;Strange Service Provider Location Machinery&lt;/h3&gt;
&lt;p&gt;JNDI predates the &lt;code&gt;java.util.ServiceLoader&lt;/code&gt; class, so it&amp;rsquo;s no surprise
that its mechanism for finding service provider classes is a bit
arcane.&lt;/p&gt;
&lt;h3 id=&#34;too-much-hierarchy&#34;&gt;Too Much Hierarchy&lt;/h3&gt;
&lt;p&gt;As noted earlier, for configuration system purposes, a tree model is
not necessary.  In most specifications, if you find that something is
not necessary, you leave it out.  There doesn&amp;rsquo;t seem to be a need for
there to be an intermediate &lt;code&gt;Context&lt;/code&gt; &amp;ldquo;in between&amp;rdquo; any two name
components, but it fit a mental model the Naming Service Specification
authors were familiar with, and JNDI tracked that specification, so
here we are.&lt;/p&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;JNDI is an old and clunky API with solid conceptual underpinnings that
addresses most, if not all, concerns that any Java-centric
configuration system will encounter.  It is worth using as a kind of
rubric to check any configuration system implementation against for
correctness.&lt;/p&gt;
&lt;h2 id=&#34;whats-next&#34;&gt;What&amp;rsquo;s Next&lt;/h2&gt;
&lt;p&gt;In a future post, I hope to write about JAX-RS from a Java-centric
configuration system perspective.  Seen through this lens, JAX-RS is a
very interesting system for acquiring Java &lt;code&gt;Object&lt;/code&gt;s based on a
combination of names and qualifiers and MIME types, auto-discovering
providers and negotiating and resolving ambiguities.  If you combine
its concepts with JNDI&amp;rsquo;s notion of namespaces and self-bootstrapping,
a design for a Java-centric configuration system falls out rather
easily.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Welcome</title>
      <link>https://ljnelson.github.io/blog/welcome/</link>
      <pubDate>Fri, 17 Dec 2021 16:08:01 -0800</pubDate>
      <author>ljnelson@gmail.com (Laird Nelson)</author>
      <guid>https://ljnelson.github.io/blog/welcome/</guid>
      <description>&lt;p&gt;Hello and welcome to my new blog.&lt;/p&gt;
&lt;p&gt;My &lt;a href=&#34;https://lairdnelson.wordpress.com/&#34;&gt;old blog&lt;/a&gt; is still available.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Search</title>
      <link>https://ljnelson.github.io/search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>ljnelson@gmail.com (Laird Nelson)</author>
      <guid>https://ljnelson.github.io/search/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
