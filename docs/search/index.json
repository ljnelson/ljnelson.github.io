[{"content":"","href":"/","title":"Home"},{"content":"","href":"/tags/config/","title":"config"},{"content":"","href":"/tags/java/","title":"java"},{"content":" Table Of Contents  Background and Rationale What\u0026rsquo;s In A (Naming Service) Name?  The Object Management Group Naming Service Specification JNDI  Bootstrapping Retrieval Operations Binding Operations Name-to-Object Bindings Synthesizing Operations     Putting It All Together    Background and Rationale I\u0026rsquo;ve written previously about how Java configuration systems boiled down to their essence are simply systems for loading Java objects that are described in a particular way, usually by some kind of name (along with qualifiers), and that such systems have absolutely nothing to do with dependency injection.\nThese ideas are not new. In the Java enterprise world, they first showed up in a systematic way in the Java Naming and Directory Interface (JNDI) API. This API, in turn, is a slight modernization, and idiomatic Java translation, of the Object Management Group\u0026rsquo;s Naming Service Specification, which quietly stagnated sometime in 2004.\nSomewhere along the line, JNDI got (wrongly) pigeonholed as just a way to access LDAP servers. I\u0026rsquo;m going to ignore that entire side of things (the \u0026ldquo;directory\u0026rdquo; part), because that\u0026rsquo;s not what JNDI primarily is at all.\nThen it got demonized because of the java: URL scheme and the comp/env naming prefix mandated by the Java EE Platform Specification to identify a component\u0026rsquo;s environment, but, as we\u0026rsquo;ll see, the concept underlying this prefix is critical, regardless of how clunky the actual implementation turned out to be.\nNow it is routinely rejected more because of its age than because of any technical limitations it might have. Having said that, it most certainly shows its age, and not in a good way.\nSo why would we look at all this? Because to this day it is the only Java-related configuration-like system that has appropriately considered most, if not all, the concerns that arise when you talk about loading Java objects that are qualified in some way into a class—the very heart of Java-centric configuration use cases.\nIt\u0026rsquo;s somewhat bizarre to note that the Java-centric configuration frameworks currently en vogue are so comparatively deficient:\n  MicroProfile Config certainly has not considered these concerns. (As I\u0026rsquo;ve written before, it is non-deterministic and subject to namespace clashes.)\n  Lightbend\u0026rsquo;s TypeSafe Config has not considered these concerns. (Names are considered to be absolute.)\n  Spring has not considered these concerns. (Names are considered to be absolute and configured objects are presumed to \u0026ldquo;belong\u0026rdquo; to the Spring ecosystem.)\n  Jakarta Config is stumbling backwards into these concerns without realizing they are valid concerns, and is repeating the egregious mistakes of MicroProfile Config before it. (It is non-deterministic and subject to namespace clashes and is focusing its standardization efforts in irrelevant places.)\n  I\u0026rsquo;m sure there are others.\nWhat if we could extract the age-old lookup-and-namespace-related concerns that JNDI addresses and re-express them with a modern API? That would make for a pretty decent Java-centric configuration API.\nTo catch a glimpse of these concerns and how they are addressed within JNDI requires a little bit of squinting. The JNDI API itself is old and outdated by today\u0026rsquo;s standards. It predates generics, for one thing, and attempts to modernize it, regardless of how trivial, have been gently and officially rebuffed. For another, it predates the java.util.ServiceLoader convention of discovering service providers at startup. Getting past these anachronisms and others like them can be a little tricky, but the journey is worth it.\nWhat\u0026rsquo;s In A (Naming Service) Name? Let\u0026rsquo;s talk about what a naming service does, and why the terms even exist, and, as a result, why no one ever thinks of \u0026ldquo;naming service\u0026rdquo; in the same breath as \u0026ldquo;configuration\u0026rdquo; (but maybe they should).\nFirst, we\u0026rsquo;ll talk about JNDI\u0026rsquo;s precursor, the Object Management Group\u0026rsquo;s Naming Service Specification. I know: CORBA—but bear with me.\nThe Object Management Group Naming Service Specification Let\u0026rsquo;s revisit the 1990s for a moment. How do you do, fellow kids?\nBack in CORBA\u0026rsquo;s day, you could park distributed objects on one machine, and use another machine to look them up, and the calling program might be written in an entirely different language from the serving program. The sub-programs doing the actual retrieval and serving were known as ORBs: object request brokers. As you might imagine, an object request broker turns a simple local request for a particular object into a distributed request for that object, and answers such remote requests as well.\nBecause CORBA is cross-language, this meant that each ORB had to be able to park an object under some kind of location that any requestor could specify in some way, regardless of the languages involved. All languages have strings, and CORBA had ironed out the various language- and machine-related discrepancies among strings, so the way you identified the object you wanted to retrieve from some other ORB was to effectively just name it. So a naming service, then, is something that, when given a string-typed, address-like name of some kind, gives you back an object bound under that name, suitable for immediate use in the calling language. (Usually there was a hazy presumption that something remote-ish had occurred, e.g. you had retrieved an object over the network from some other machine somewhere. This was because so-called distributed objects were cool. Now we know better, but the (mostly valid) concepts involved apply even locally, as we\u0026rsquo;ll see.)\n(More importantly for configuration-related purposes, a name\u0026rsquo;s sole function, really, is to help distinguish one typed object from another object bearing the same type.)\nGetting ORBs from different vendors to cooperate was tough, so there were a lot of specifications that ended up being written by the Object Management Group. One of them was a specification governing hierarchical naming semantics, named, appropriately enough, the Naming Service Specification.\nThere\u0026rsquo;s nothing that says, inherently, that a naming service has to be hierarchical. But hierarchies can be convenient, and the Naming Service Specification decided to formally specify tree-based naming semantics instead of flat ones. The root of a naming service tree is a context; its nodes are objects; its branches are names.\n(A context, of course, is also a kind of object, and again, while specifying the notion of a child context is not required, that\u0026rsquo;s how the Naming Service Specification decided to do it.)\n(Some of this hierarchical stuff was due to the inherent chattiness of CORBA itself: you didn\u0026rsquo;t want to traverse deep graphs with remote calls for each traversal operation! Better to grab a context and use it directly to get its stuff.)\nAmong other things, all of this means that, in the Naming Service Specification, any given name is always relative to a parent context. There are no absolute names. If I give you a name, you don\u0026rsquo;t know what it means or designates (in the absence of other information). But if I tell you that it\u0026rsquo;s relative to a particular context, then you have the tools to be able to resolve the name against that context and find the object it points to. A context turns out to be a namespace (among other things).\n(In the world of name-based configuration this concept is absolutely critical. It is ignored by all major Java-centric configuration frameworks for no good reason that I can see.)\nIn the Naming Service Specification, names have structure. A sequence of components within a name forms a compound name. Its individual components are also known as simple names. Finally, if you have a compound name with two components (simple names), there is also one context involved: the one that the first component desginates, and to which the second component is relative. (To belabor an earlier point, note that the first component (simple name) is relative to some context but in this example I haven\u0026rsquo;t told you what it is, so, standing on its own, this hypothetical compound name is rather useless.)\nThe Naming Service Specification also gestures feebly at another type of identifier that is sort of part of names: kind. It reads, in part:\n The kind attribute adds descriptive power to names in a syntax-independent way. Examples of the value of the kind attribute include c_source, object_code, executable, postscript, or “ ”. The naming system does not interpret, assign, or manage these values in any way. Higher levels of software may make policies about the use and management of these values. This feature addresses the needs of applications that use syntactic naming conventions to distinguish related objects. For example Unix uses suffixes such as .c and .o. Applications (such as the C compiler) depend on these syntactic convention to make name transformations (for example, to transform foo.c to foo.o).\n (This reads as a kind of primitive precursor to MIME types. It also demonstrates, inadvertently, that any system that uses a \u0026ldquo;name\u0026rdquo; to look something up eventually realizes that it must use qualifiers to look something up instead. JAX-RS matrix parameters are another example of this sort of thing. There\u0026rsquo;s plenty more to say about this, but not here.)\nJNDI JNDI\u0026rsquo;s naming services are a very straightforward translation of the language-independent terminology of the Naming Service Specification into relatively idiomatic Java terms.\nJNDI, like the Naming Service Specification, has a Context, which, like its namesake, is a locus of Names that designate Objects (including other Contexts). (A Context belongs to a naming system, which is a conceptual entity seemingly introduced by the JNDI specification and not really present in the Naming Service Specification.)\nJNDI\u0026rsquo;s Names are like those of the Naming Service Specification, but do not explicitly include the concept of simple names. Instead, a JNDI name is always either a compound name, even if it has only one component, or a composite name, a term not mentioned in the Naming Service Specification. (Composite names were added in a JNDI specification revision, and allow a single name to automatically span actual naming systems, with sophisticated parsing semantics.) Within any given naming system, hierarchical or flat, you\u0026rsquo;re always working with compound names.\nLike the Naming Service Specification, any given JNDI Name is always relative to a parent Context.\nBootstrapping JNDI allows an implementor to bootstrap itself. This is unique, even today.\nSpecifically, the InitialContext class is just a Context implementation that finds a \u0026ldquo;real\u0026rdquo; Context implementation to use, and then delegates all operations to it. The JNDI bootstrap mechanism, which predates the java.util.ServiceLoader service provider approach but which seems to have served as its inspiration, allows custom InitialContext implementations to be supplied from outside of the framework.\nThis means, among other things, the Context to which primordial Names are relative is highly customizable, even by end users.\nIn today\u0026rsquo;s Java world, someone would probably have introduced (needlessly) a builder-style object, or a whole scaffolding framework for finding the root Context. In JNDI, you just call new InitialContext() and you\u0026rsquo;re done, as it should be.\nRetrieval Operations From the looking-things-up perspective, that\u0026rsquo;s about it. Get your hands on a Context, ask it for an Object under a particular Name, and make use of the resulting Object. Where the Object came from, how it was bound, whether it was synthesized out of other Objects, whether various kinds of links and redirects were followed, whether the Object fronts some other kind of system—none of these things are your concern. You named an Object, you resolved that name against a Context, and you took delivery of that Object.\nOf particular note, you probably also cast that Object to a type you were expecting. More on that later. Peeking ahead for a moment, a name always has a conceptual type that the caller, for the most part, is expecting.\nBinding Operations Since JNDI emerged from the CORBA world and was a faithful carryover of the Naming Service Specification, it also handled the \u0026ldquo;writing side\u0026rdquo; of naming services. Placing an Object under a Name in JNDI is known as binding. For my purposes, I\u0026rsquo;ll be ignoring all binding operations. Java EE, in fact, one of the earliest consumers of JNDI, required that Contexts exposed to the end user be read-only, and it\u0026rsquo;s a regrettable fact (in my opinion) that the mutating operations of JNDI were not split into their own sub-specification.\nName-to-Object Bindings For ordinary use cases, a Name in JNDI is always conceptually bound to some kind of Object. This means that a Name, regardless of how many components it might have, also has an effective (Java) type, namely, that of the Object that it references.\nJNDI has a few clunky introspective APIs for listing bindings, but for my purposes I\u0026rsquo;m going to ignore them, since in configuration use cases you already know the name of the thing you\u0026rsquo;re looking up. What\u0026rsquo;s mainly important here is that a Name, when resolved against a Context, is effectively typed by a Java class.\nSynthesizing Operations JNDI has a facility, not found in the Naming Service Specification, that permits some other Java object to synthesize a Java object out of \u0026ldquo;raw materials\u0026rdquo;, any of which may be bound in a tree rooted at any Context. This object doing the synthesizing is called an ObjectFactory. A JNDI implementation itself can supply ObjectFactory instances, but, more importantly for this article\u0026rsquo;s purposes, so can users and component providers.\nThis sounds complicated but is actually fairly simple.\nRecall that when you look something up in a JNDI tree rooted under a Context, you are blissfully unaware of the name resolution process (how the Object that is eventually delivered to you came to exist). Was it put together out of other things? Was it created out of nothing? Was it loaded from disk? Served over the network? You don\u0026rsquo;t know and you don\u0026rsquo;t care.\nFor certain cases, name resolution is absurdly simple: someone explicitly bound a textual string into a Context under, say, the name \u0026ldquo;hoopy\u0026quot;; you asked for the Object bound under \u0026ldquo;hoopy\u0026quot;; and lo and behold you got back that very string—perhaps \u0026ldquo;frood\u0026quot;—as a Java String object. Nothing fancy here.\nObjectFactory In other cases, an ObjectFactory gets involved. This happens because the Context::lookup operation delegates, in all implementations that I\u0026rsquo;m aware of, and perhaps explicitly stated somewhere, to a call to the NamingManager::getObjectInstance method, which pulls in ObjectFactory instances to actually perform the creation (or retrieval, or synthesis, or whatever) of a Java Object for a given Name.\nSo backing up from the minutiae for a moment, depending on what ObjectFactory instances are on the classpath and properly designated, a JNDI implementation may synthesize Objects out of thin air as if they were bound explicitly to various Names.\nObjectFactory instances and explicit binding can work together, too. An administrator can bind a Reference into a JNDI implementation that explicitly names the ObjectFactory to use to perform the actual name resolution.\nURL Context Factory One kind of ObjectFactory is one that plays the role of a URL context factory. These kinds of ObjectFactory implementations can create Contexts to represent particular URL schemes, such as, most infamously, java:, which is at the heart of the Java EE (and now Jakarta EE) specifications.\nThe notorious java:comp/env \u0026ldquo;prefix\u0026rdquo; is, more specifically, a URL whose semantics are strictly defined by the Java EE (now Jakarta EE) Platform Specification. java: causes a URL context factory specified by the Platform Specification to come into the picture, and comp/env is a compound name, relative to the root Context created by the URL context factory, denoting, by definition, a Context with very specific semantics. One of its specific semantics is very interesting to configuration systems, because it disambiguates component namespaces. That is, if an EJB refers to a Frood stored under the name hoopy, and another EJB refers to a Towel stored under the name hoopy, no conflict can occur, so long as hoopy is relative to java:comp/env in both cases.\nNo Java-centric configuration framework that I\u0026rsquo;m aware of other than JNDI addresses this extremely important concern.\nPutting It All Together So backing up to the conceptual level, JNDI provides the ability for two names to be used by two different components developed in isolation to refer to two different things, with at least the possibility that a name clash will not occur (one component\u0026rsquo;s java:comp/env Context is not the same Context as another component\u0026rsquo;s java:comp/env Context).\nIn addition, it allows for user-supplied factories to handle individual name resolution operations. There is a defined search order for discovering such factories. You supply a name, the system searches until it finds something that can make Objects for that name.\nJNDI properly separates the lookup use cases (ask for an Object of a particular type by name; receive it) from the binding and administration use cases (install an ObjectFactory that knows how to make an Object of a particular type; bind that ObjectFactory to a particular name), to such a degree that there could have been two specifications instead of one.\nOperations such as conversion and object binding are deliberately left unspecified, as it should be. That is, any given ObjectFactory may do whatever it wishes to come up with an Object for a given name resolution request.\nAt an abstract level, a compound name is a typed path, whose intermediate nodes may have known types as well.\nIf we strip some of the terminology and API cruft away we can say the following:\n In JNDI and configuration systems, there is some kind of root object to which notional paths are relative.  In JNDI this is a Context and the rootiest of all root Contexts is an InitialContext, as the name accurately reflects.   In JNDI and configuration systems, you locate an Object by supplying that root object with a typed path that designates the Object to retrieve.  In JNDI this is a CompoundName supplied to the Context::lookup method, and if you need to figure out what the type is, you can invoke any of several crufty methods to find the relevant Class.   In JNDI and configuration systems, some accessory piece of technology that is registered under that typed path is actually responsible for making the requested Object come into existence.  In JNDI, this is an ObjectFactory invoked by way of the NamingManager::getObjectInstance method.    ","href":"/blog/java-configuration-jndi-and-naming-operations/","title":"Java Configuration: JNDI and Naming Operations"},{"content":"","href":"/tags/jndi/","title":"jndi"},{"content":"","href":"/tags/","title":"Tags"},{"content":"","href":"/tags/personal/","title":"personal"},{"content":"Hello and welcome to my new blog.\nMy old blog is still available.\n","href":"/blog/welcome/","title":"Welcome"},{"content":"Older Posts There is a prior version of this blog that contains my older posts.\nRecent Posts Recent posts may be found below.\n","href":"/blog/","title":"Blog"},{"content":"","href":"/authors/","title":"Authors"},{"content":"","href":"/categories/","title":"Categories"},{"content":"","href":"/page/","title":"Pages"},{"content":"","href":"/search/","title":"Search"},{"content":"","href":"/series/","title":"Series"}]
