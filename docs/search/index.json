[{"content":"","href":"/","title":"Home"},{"content":"","href":"/tags/config/","title":"config"},{"content":" Table Of Contents  Determinism, Presence and Absence Determinism Presence and Absence Introducing OptionalSupplier    Determinism, Presence and Absence In this ongoing series related to Java configuration I\u0026rsquo;ve most recently covered what qualifiers are. They are strongly related to what paths are. A path picks out some possible objects in objectspace. Those objects may or may not exist. Whether they are known to exist, and for how long, is the subject of this post.\nDeterminism Determinism is, very loosely speaking: if you put the same stuff in twice, you\u0026rsquo;ll get the same result twice.\nWhat does \u0026ldquo;same\u0026rdquo; mean? For most purposes, \u0026ldquo;same\u0026rdquo; can simply mean \u0026ldquo;indistinguishable\u0026rdquo;.\nIf I have a sane implementation of public final int add(final int a, final int b), then if you call this method 47 times, supplying it with 1 and 1 respectively each time, you\u0026rsquo;ll get 2, each time.\nWhy does this matter in configuration land? It\u0026rsquo;s kind of a Schrödinger\u0026rsquo;s cat situation.\nLet\u0026rsquo;s say you have a Supplier\u0026lt;? extends String\u0026gt; in your hand and you\u0026rsquo;re about to call its get() method. Will it return a value?\nWill it throw an exception?\nYou don\u0026rsquo;t know until you try it. So OK, let\u0026rsquo;s say you call it. Boom: it throws an exception.\nIf you call it again, will it throw an exception again? Will it be an exception that is indistinguishable from the prior one? Or will you get a value this time?\nYou don\u0026rsquo;t know; you have to try it. So OK, let\u0026rsquo;s say you call it again. This time it returns \u0026ldquo;Hello, world!\u0026rdquo;.\nThis supplier is non-deterministic. There\u0026rsquo;s no way to know what it is going to do. To learn what it\u0026rsquo;s going to do, you could read the documentation, which might or might not be correct. Perhaps the documentation mentions that it could throw a NoSuchElementException at any point for any reason. Now you know it\u0026rsquo;s non-deterministic. It would be kind of nice if this information were actually available programmatically.\nSuppose this time you have a different Supplier\u0026lt;? extends String\u0026gt; in your hand. Suppose you call it 347 times and it returns \u0026ldquo;Hello, world!\u0026rdquo; each of those times. Is it deterministic? Maybe; you still don\u0026rsquo;t know.\nDeterminism is critical in configuration land because it helps you understand when a piece of configuration might change (and I haven\u0026rsquo;t even begun to dive into the fetid swamp that is mutable configuration) and when it is guaranteed (to the extent possible) to be constant.\nPresence and Absence Some values in configuration land are present. If I ask a loading system for a type of qualified object, the loading system might return me a suitable value. That value is present: I asked for it, and I got it. (If I ask a loading system for it again, will I get the same object back? That\u0026rsquo;s determinism, an orthoganal concept.)\nSome values in configuration land are absent. If I ask a loading system for a type of qualified object, the loading system might not return me a suitable value. That value is absent: I asked for it, and I didn\u0026rsquo;t get anything. Again, determinism and absence are orthogonal.\nAdditionally: presence and absence have nothing to do with null. Some present values can be null and it\u0026rsquo;s entirely possible to represent absence with an object.\nLet\u0026rsquo;s go back to the Supplier example. If you were able to query the Supplier to see what sorts of machinery it hides, you could see whether you might have to call get() one time or many times, and you could tell whether, if it returns null, that represents the presence of a value explicitly set to null or the absence of a value altogether.\nIf you could also query the supplier to find out whether the presence or absence it reports is permanent or transient, then you would also know whether it was deterministic.\nIn practice, these orthogonal concepts can be folded together into, say, an enum whose values might be:\n  ABSENT: describes permanent (and hence deterministic) absence. In the Supplier example, there really isn\u0026rsquo;t any point to calling the get() method. If we say that absence is indicated by the throwing of an exception, for example, then any time you call get() you are guaranteed it will throw an exception.\n  PRESENT: describes permanent (and hence deterministic) presence. In the Supplier example, you can call the get() method once and be confident that you\u0026rsquo;ll receive the one value it will forever return. That value, of course, might be null.\n  DETERMINISTIC: describes permanent absence or presence, but you don\u0026rsquo;t know which until you try. In the Supplier example, maybe get() will return a value (which may be null) and maybe it will throw an exception. Whatever it does, it will do for every subsequent invocation. That\u0026rsquo;s useful.\n  NON_DETERMINISTIC: who knows what will happen. This is the default mode of Suppliers everywhere.\n  Some configuration systems clumsily stumble around these concepts, some with better results than others:\n  MicroProfile Config and good old System properties are the worst here, since they conflate the concept of null and, in some cases, empty strings, with value absence. Oops. At least you can test if the System properties contain a key to discover absence vs. presence of a given value.\n  Lightbend\u0026rsquo;s Typesafe Config tries very hard to do this but still falls down a little bit. You can dig into the hasPathOrNull(String) javadoc to see the gymnastics, and don\u0026rsquo;t forget to consider that although it calls itself an immutable configuration system there\u0026rsquo;s also invalidateCaches() to pay attention to. So much for determinism!\n  JNDI at least knows that null is a valid value, so defines the NameNotFoundException type, so you can distinguish between absence and presence. In theory, a Context\u0026rsquo;s environment could contain this information, but it is not standardized.\n  Jakarta RESTful Web Services is obviously an HTTP-centric specification and so can take advantage of the various HTTP caching directives.\n  Introducing OptionalSupplier To solve this problem, let\u0026rsquo;s introduce OptionalSupplier.\nWait, you say, how come we can\u0026rsquo;t just use java.util.Optional? Because Optional is designed for Stream operations that cannot or should not return null, and so deliberately equates null with \u0026ldquo;emptiness\u0026rdquo;, a concept similar to, but not equal to, absence.\nNevertheless, some of the fluent methods on Optional are quite useful. So what if we took the spirit of java.util.Optional and applied it to a Supplier, with explicit rules on how get() behaves, allowing for the possibility of null as a valid value?\nThen you could do things like this:\nswitch (optionalSupplier.determinism()) { case ABSENT:  // You\u0026#39;re never going to get a value; use a default  // value instead maybe. Or you could throw an exception.  // Or you could go ahead and call get() and let *it*  // throw an exception to indicate absence. Here we  // use a default value.  greeting = \u0026#34;Hello, world!\u0026#34;;  break; case PRESENT:  // You only have to call get() once, and it won\u0026#39;t throw.  // It will always return the same value. You could use  // this information later to decide what to do about  // caching and such. Note the lack of the try/catch block.  greeting = optionalSupplier.get();  break; case DETERMINISTIC:  // Whatever get() does, it will always do, but we don\u0026#39;t  // know what it will do. Guard appropriately. With this  // information you might be able to decide caching semantics  // or abort early.  try {  greeting = optionalSupplier.get();  } catch (final NoSuchElementException permanentlyAbsent) {  // forever absent; use a default value, maybe?  greeting = \u0026#34;Hello, world!\u0026#34;;  }  break; case NON_DETERMINISTIC:  // We don\u0026#39;t know what get() is going to do when it is called.  // Guard appropriately, and now you know that greeting shouldn\u0026#39;t  // be cached, or, if you want to cache it, that a new value for  // it might be returned by a get() invocation at any time.  try {  greeting = optionalSupplier.get();  } catch (final NoSuchElementException absentForNow) {  // Absent, but optionalSupplier.get() might return a  // present value later. For this example we just use a  // default value.  greeting = \u0026#34;Hello, world!\u0026#34;;  }  break; default:  throw new AssertionError(\u0026#34;Impossible enum constant: \u0026#34; + optionalSupplier.determinism()); } Or you could do some fluentish stuff like this:\n// This looks just like Optional.orElse(), but of course at the // end of all this greeting may very well be null. Absence is // not java.util.Optional emptiness. String greeting = optionalSupplier.orElse(\u0026#34;Hello, World!\u0026#34;); // This assertion, in other words, might fail: // assert greeting != null So now we have notions of what a path is, what qualifiers are, and whether any given value in configuration land is permanently or transiently present or absent. There\u0026rsquo;s just one last foundational piece to this whole thing, and that\u0026rsquo;s subtyping and Java type assignability semantics—coming up next.\n","href":"/blog/presence-and-absence/","title":"Determinism, Presence and Absence"},{"content":"","href":"/tags/java/","title":"java"},{"content":"","href":"/tags/","title":"Tags"},{"content":" Table Of Contents  Qualifiers JSR-330 and Jakarta Dependency Injection Qualifiers, Suitability and Ambiguity Qualifiers and Just Enough Set Theory The Model    Qualifiers In this ongoing series related to Java configuration, I\u0026rsquo;ve most recently covered what a path is. I described what a path consists of, and introduced the notion of qualifiers.\nIn this post I\u0026rsquo;ll talk a bit more about qualifiers.\nJSR-330 and Jakarta Dependency Injection I think that good old JSR-330 (now Jakarta Dependency Injection) was the first to explicitly define the notion of a qualifier. In Jakarta Dependency Injection\u0026rsquo;s case, a qualifier is necessarily an annotation, but disregard that for the time being, because it\u0026rsquo;s not at all important.\nThe documentation is terse to the point of being almost useless, but if you look at it long enough you start to see that a qualifier—the abstract notion, mind you—is an immutable value for an immutable, usually unnamed, implied attribute. (I\u0026rsquo;ve been somewhat fascinated by all this for quite a while now.)\nSo in the Jakarta Dependency Injection documentation, the @Leather annotation represents a value for some sort of unnamed key, say, material.\nWhat\u0026rsquo;s so special about a qualifier being an annotation? Nothing. Making a qualifier an annotation is an easy way to create an immutable key value pair, that\u0026rsquo;s all.\nIn Jakarta Dependency Injection, a class can be annotated with many qualifier annotations. That just means it can have many qualifiers, i.e. a set of immutable key value pairs.\nTogether, a type and qualifiers constitute a path as we\u0026rsquo;ve defined it. That\u0026rsquo;s interesting.\nThat is: in Jakarta Dependency Injection, when you ask for a conformant system to inject an object, you are asking it to supply you with an object of a particular type and with particular qualifiers. The actual machinery that does this isn\u0026rsquo;t concerned with injection at all. It\u0026rsquo;s just logically making a path of sorts out of the information you\u0026rsquo;ve supplied (the type and qualifiers) and satisfying the loading request.\nHmm, this all sounds familiar, doesn\u0026rsquo;t it?\nQualifiers, Suitability and Ambiguity In fact, the conformant system will frequently not have exactly the object you were looking for, but it may have one that is suitable. The concepts of qualifiers and suitability are intertwined and we\u0026rsquo;ll come back to their relationship soon.\nAt this point we\u0026rsquo;ve come to realize a few important things:\n A qualifier is just an additional facet of a load request. A qualifier doesn\u0026rsquo;t have to be an annotation. Qualifiers have nothing intrinsically to do with dependency injection. It\u0026rsquo;s just that JSR-330 happens to have defined the term. In systems that use qualifiers, a request might be fufilled with something that is exactly what was requested, or something that was suitable for the request.  In a dependency injection system, ambiguity is the enemy. Sometimes a load request will exactly identify one object. In that case, the dependency injection system satisfies the load request and everything is great. Sometimes a load request, however, will identify two different objects that are both suitable. The dependency injection in this case normally fails the request and reports that there was ambiguity.\nIn a configuration system, ambiguity is not necessarily the enemy. Frequently there are suitable values that get ranked or prioritized or stacked or otherwise arranged so that you always get something if at all possible. This is largely because configuration, unlike business objectspace, describes many different environments.\nBut apart from the ambiguity angle, a configuration system is just a dependency injection system without the injection part.\nNow let\u0026rsquo;s come back to ambiguity and qualifiers and suitability.\nLet\u0026rsquo;s say I ask for a String under the name hostname. As we\u0026rsquo;ve seen, a path can be reduced to a set of qualifiers, so this could be represented in notation I just made up like this:\n{ name = hostname, type = java.lang.String } Let\u0026rsquo;s actually refine this. Let\u0026rsquo;s say that I still ask for a String under the name hostname, but somehow the fact that my class that is doing this is in an application that is running in the test environment gets captured. That might look like this:\n{ name = hostname, type = java.lang.String, env = test } Let\u0026rsquo;s refine this again. Let\u0026rsquo;s say that I still ask for a String under the name hostname, but somehow the fact that my class that is doing this is in an application that is not only running in the test environment but also in the west region:\n{ name = hostname, type = java.lang.String, env = test, region = west } Let\u0026rsquo;s further suppose that the loading system doesn\u0026rsquo;t actually have a value that exactly matches all this. Let\u0026rsquo;s say that it can furnish a value whose type is java.lang.String, whose name is hostname and whose region is west (note: no env setting). Should this value \u0026ldquo;match\u0026rdquo; or not? Is this value suitable, in other words?\nOr: given a request path of { name = hostname, type = java.lang.String, env = test, region = west }, does a value path of { name = hostname, type = java.lang.String, region = west } match? Is it suitable?\nIn a dependency injection system like CDI, the answer is no: the injection point—the request path—does not have a subset of the qualifiers of the proposed value. Game over.\nBut there is a sense in configuration land that we do want this value to be suitable. It\u0026rsquo;s not maximally suitable, since it doesn\u0026rsquo;t exactly match all the qualifiers, but it doesn\u0026rsquo;t redefine any of them (i.e. the name, type and region qualifiers all have the same values as those of the request).\nQualifiers and Just Enough Set Theory If we try to translate this intuitive sense into something a little more concrete, it becomes clear that, for a given key, a set of qualifiers that omits that key is suitable for a set of qualifiers that specifies that key. But a set of qualifiers that has a different value for that key is not suitable.\nIt also turns out that if a set of qualifiers has keys in it that are not present in a requested set of qualifiers, that\u0026rsquo;s suitable too, though maybe not as suitable as we\u0026rsquo;d like.\nFrom this we know that a model of qualifiers will need to be able to report the intersection between two sets of qualifiers: the key value pairs they have in common. And we know that this model will need to be able to report the symmetric difference between two sets of qualifiers: the key value pairs that are contained in one but not the other.\nFinally, given that qualifiers are likely to be represented persistently, a set of qualifiers must have a defined iteration order so that arbitrary changes in set ordering do not impact suitability calculations.\nThe Model Putting it together, we can therefore say something like this:\n A Qualifiers is an immutable set of entries. An entry is an immutable pairing of a Comparable and an immutable object value. A Qualifiers can report its size. A Qualifiers may be empty. A Qualifiers can report its intersection size with respect to another Qualifiers. A Qualifiers can report its symmetric difference size with respect to another Qualifiers. Because of all this, Qualifiers is a value-based class.  We\u0026rsquo;ve now sketched what qualifiers look like, and what a path made up of them looks like. We\u0026rsquo;ve also hinted at ambiguity and suitability. In the next post, we\u0026rsquo;ll look at the notions of determinism, presence and absence, which are the last foundational pieces to any configuration system.\n","href":"/blog/qualifiers/","title":"Qualifiers"},{"content":" Table Of Contents  Paths    Paths In this ongoing series related to Java configuration, I\u0026rsquo;ve most recently covered what it might look like if you had a ServiceLoader that could take requests. I introduced the notion of a path, a sparsely populated pointer of sorts to objects in objectspace. Paths are not new, of course, and are present in everything from filesystems to JNDI to Jakarta RESTful Web Services.\nIn this post I\u0026rsquo;d like to dive a little deeper into how a path might be put together.\nA path is used for addressing, so we want it to be as specific as we can possibly get it. What does that mean?\nMany times when we think about paths we think of them as if they were simply names. Their elements, in this model, are simple strings, and they are separated by some kind of a separator, and that\u0026rsquo;s it.\nThis isn\u0026rsquo;t nearly enough for a configuration system addressing scheme. Weirdly, several different configuration systems take this approach, and it is exactly because they take this approach that they are deficient.\nLet\u0026rsquo;s look back at JNDI again. While JNDI paths consist of name elements in a sequence, each element also has an environment. An environment in this system is just a bunch of key value pairs that \u0026ldquo;ride with\u0026rdquo; the path element (named Context in JNDI).\nOr let\u0026rsquo;s look at Jakarta RESTful Web Services again. While paths there also consist of elements in a sequence, there are also headers and matrix parameters that might logically belong to each element in the sequence. More key value pairs, if you squint in the right way.\nFinally, if you look at all paths in a certain way, you can see that at their absolute heart they are nothing more than key value pairs all the way down. They aren\u0026rsquo;t represented this way, of course, but fundamentally a JNDI Context with an environment that contains a = b and that is identified by a name of a/b/c is really just a collection of key value pairs that consists of {a = b, name = a/b/c}.\nThis insight is kind of important. It means that when a loader receives a request to load an object, it is, at some fundamental level, receiving an immutable set of key value pairs describing the request. Once you see this you can\u0026rsquo;t unsee it, and names-with-separators addressing schemes just don\u0026rsquo;t measure up.\nIt is nevertheless true that some of these key value pairs are often more important to the human reader than others. In the case of a JNDI Context, the name itself is quite important since you always have to have one and the way it is represented indicates the depth of a hierarchy that might or might not be present. Similarly, in Jakarta RESTful Web Services, the length of a path often tells you something, just by looking at it, about the specificity of the request. So representing the value of a hypothetical name key with a value that is a sequence of names makes some sense.\n(Names, as frequently mentioned on this blog, always have implicit namespaces, so it\u0026rsquo;s important that paths\u0026rsquo; names be able to be transliterated: if you, a class developer, decide that your path is going to have a name of a/b, and I, an application assembler, know that a/b is already spoken for by another class developer, then I have to have a way to reconcile this name clash.)\nSimilarly, there are plenty of implicit key value pairs that are part of a path even when the path builder doesn\u0026rsquo;t supply them explicitly. For example, the current Locale or operating system might very well be a key whose value might help a loader find an appropriate object. Frequently these sorts of situational parameter values are not explicitly supplied by a user, but are understood nevertheless to be part of the loading request. Making these of secondary concern seems like a good thing to do.\nFinally, paths in all systems that use them have an implicit or explicit type. A filesystem path ends in a type (e.g. java.io.File or java.nio.file.Path). A JNDI Name ends in a type, but Java lacked the syntax to fully describe it; you can see the footprints in the NameClassPair class. A Jakarta RESTful Web Services path (of type GET (oh look, another key value pair that rides with the request!)) terminates in an entity of a particular type. The type is, of course, just another key value pair, logically speaking (type = java.nio.file.Path), but is also a key value pair that is borne by all paths. So it might make sense to represent it explicitly and elevate its primacy.\nWhen we put this all together we get something like this:\n A Path is a sequence of Path.Elements. A Path has Qualifiers that are the key value pairs that qualify it. A Path\u0026rsquo;s final Path.Element has a type, which is also the type of the Path.  Other Path.Elements need not have a type.   Each Path.Element has a name.  A Path.Element must be able to be transliterated without changing source code.   Each Path.Element has Qualifiers that qualify it and no other Path.Element. Any given Path.Element may or may not have a type, but a Path.Element that ends a Path must have a type. A Path\u0026rsquo;s Qualifiers includes qualifiers that qualify the path as a whole as well as the appropriately-scoped Qualifiers from each of its Path.Elements.  Note that each Path.Element in the model described above does not have a type (paths can be sparsely populated). So this does not imply any kind of hierarchy, nor should it.\nI\u0026rsquo;ve quietly introduced the notion of a Qualifiers, which is basically a read-only set of immutable key value pairs with a defined iteration order. A Qualifiers may be empty.\nAgain, just for the thought experiment, it\u0026rsquo;s worth remembering that a Path could be fully represented as a Map with required name and type keys that have non-null values. But for the reasons listed above it\u0026rsquo;s better to represent it as its own thing.\nSince I\u0026rsquo;m proposing to build Paths around Qualifiers, the next post will dive into them a little more deeply.\n","href":"/blog/paths/","title":"Paths"},{"content":" Table Of Contents  What Would a ServiceLoader That Could Take Requests Look Like?  Objectspace Ambiguity Addressing  ServiceLoader Addressing Jakarta RESTful Web Services Addressing JNDI Addressing   Loaders, Paths and Qualifiers   What\u0026rsquo;s Next?    What Would a ServiceLoader That Could Take Requests Look Like? In this ongoing series related to Java configuration, I\u0026rsquo;ve covered JNDI and Jakarta RESTful Web Services. Both involve loading Java Objects from potentially many providers with disambiguation algorithms built in, and both permit the application assembler to work around naming clashes. Of course, neither is a Java configuration system.\nLet\u0026rsquo;s look at some of the super-concepts these two technologies have in common.\nObjectspace The first is what I\u0026rsquo;ll call, somewhat pretentiously, objectspace. This is the notional space of all possible Java objects (and primitive types) in all possible Java virtual machines in all possible worlds. Objectspace is big.\nYou can pick out an individual object from objectspace, let\u0026rsquo;s say, by supplying some loading system with an address. (This sounds like pointers! Indeed, that\u0026rsquo;s part of the analogy I\u0026rsquo;m going for.) Give the system an address, it hands you back the corresponding object. By definition, if you provide a precise enough address there will be exactly one object it picks out, never zero. Simple. What could possibly go wrong?\nTo get an object from objectspace according to the rules as I\u0026rsquo;ve laid them out so far, you have to be remarkably precise. You\u0026rsquo;d better be able to distinguish objects by type, certainly, and whatever the addressing scheme looks like, it better take type into account. But you can\u0026rsquo;t stop there.\nAmbiguity If we do stop there, we have to address ambiguity. If I ask for what I hope is the only String in all of objectspace by asking a hypothetical loading system for the one true object that has the type String.class, the loading system will laugh in my face. There are many Strings in objectspace.\nOK, OK; I might instead want to ask this hypothetical loading system for a very particular String, namely the one in objectspace under the System property key java.home. But even this isn\u0026rsquo;t specific enough, since, remember, objectspace encompasses all Java objects in the universe. There are many Java homes. The one that identifies my Java installation is just one of them! And yet I get a single String back, so, Laird, your analogy sucks.\nAddressing Not so fast! When I ask for this hypothetical loading system to give me the java.home String, I\u0026rsquo;m actually supplying plenty of other implicit addressing information in my request, whether I know I\u0026rsquo;m doing this or not. Specifically, I\u0026rsquo;m actually asking for the only String in all of objectspace that has the type String.class, that is indexed under the System property key java.home, and on this JVM, running on this machine, on this architecture, in this universe, and so on and so forth. That may be enough to pick out the String I want (and normally is in non-hypothetical, non-abstract, non-architecture astronaut cases).\nSo types and JVM-wide names seem to be the bare minimum to pick out an object from all of objectspace. Sounds easy—but that\u0026rsquo;s not quite right either.\nLet\u0026rsquo;s say instead that I would like this loading system to fetch me the one true String that can be found in some hazy way \u0026ldquo;under\u0026rdquo; the name preferredHost (I made this up so that it\u0026rsquo;s not some key defined by Java itself). Let\u0026rsquo;s further wave our hands about possible name collisions: let\u0026rsquo;s pretend that no other developer in the entire universe could possibly ever be writing a class like mine, and no other developer in the entire universe could possibly ever mean anything semantically different from what I mean when I say preferredHost. (In practice, of course, these assumptions are completely ridiculous. Bear with me; we\u0026rsquo;ll get there.)\nBut if my application is running in test, in some sort of hazy way, then there may very well be an ambiguity here. preferredHost and String.class no longer uniquely identify a String in objectspace. Maybe there is another string value indexed under preferredHost in objectspace (that identifies the production preferredHost for example). Oh, shoot, I guess really what I was asking for all along was the one true String indexed under the explicit name preferredHost and the implicit name test. (Note that in no way was I asking for the explicit name test.preferredHost, nor did I have some kind of fallback in mind.) As a component developer, I of course didn\u0026rsquo;t know what application my component was running in, so it didn\u0026rsquo;t occur to me to check for this case. Oops.\nObjectspace is big. Like, you just won\u0026rsquo;t believe how vastly, hugely, mind-bogglingly big it is. Picking out a single Object in it is damn near impossible.\nInstead, typically what we do, while blissfully not being aware of it, is: we supply some addressing information, and then rely on some common case where we were expecting one thing, and there was only one thing that happened to match our imprecise addressing information, and we asked our loading system for it, and it responded, and we got only one thing, not 27, and it never occurs to us that 27 of those things is actually a very real possibility. Then the bugs roll in.\nGood loading system APIs recognize that no addressing system you can come up with will ever pick out an object from objectspace without some kind of further disambiguation.\nServiceLoader Addressing Let\u0026rsquo;s look at java.util.ServiceLoader as an example. This class deliberately embraces ambiguity. The only kind of addressing information you can give it is type. Ask a ServiceLoader for the thing corresponding to SomeService.class, and it will hand you back an Iterable\u0026lt;SomeService\u0026gt;. Anyone can put a service provider file on the classpath (discoverable as a classpath resource at META-INF/services/com.foo.SomeService, let\u0026rsquo;s say), and its entries will be picked up. So great, how do you filter all the various SomeService implementors? That, dear reader, is up to you.\nThe upshot is: ServiceLoader, like many loading systems, accounts for the almost completely necessary ambiguity of objectspace in its API design. Ask for a thing of a type, get back many things of that type. Your problem to solve.\nJakarta RESTful Web Services Addressing Let\u0026rsquo;s consider Jakarta RESTful Web Services. Let\u0026rsquo;s pretend that Jakarta RESTful Web Services is, among other things, a way to (again, partially) address into objectspace. After all, with a resource method you can say, effectively, \u0026ldquo;this method will return a SomeService if the addressing information matches the path a/b/c and the media type application/json.\u0026rdquo;. So if you ask this loading system for a SomeService.class object, providing no path information and no media type information, the ambiguity is reduced somewhat: this resource method I described will not \u0026ldquo;fire\u0026rdquo; and it, at least, will not be responsible for returning a SomeService. Some other resource method might. If more than one \u0026ldquo;fires\u0026rdquo;, then there is an algorithm that somewhat arbitrarily picks one.\nJNDI Addressing Let\u0026rsquo;s consider JNDI. Let\u0026rsquo;s pretend that JNDI is, among other things, a way to (again, partially) address into objectspace. After all, with a javax.naming.spi.ObjectFactory you can say, effectively, \u0026ldquo;this ObjectFactory will return a SomeService if the addressing information matches the compound name a/b/c and an expected environment.\u0026rdquo; So if you ask this loading system for a SomeService.class object, providing no compound name information and no environment information, the ambiguity is reduced somewhat: this ObjectFactory I described will not \u0026ldquo;fire\u0026rdquo; and it, at least, will not be responsible for returning a SomeService. Some other ObjectFactory might. If more than one \u0026ldquo;fires\u0026rdquo;, then there is an algorithm that somewhat arbitrarily picks one.\n(You of course see the similarity.)\nEach of these loading systems differs, of course, in what its \u0026ldquo;loaders\u0026rdquo; are permitted to do (resource methods and ObjectFactory instances have to play by the rules of their specifications). And each loading system permits more or less addressing information to \u0026ldquo;ride along\u0026rdquo; with the general request for a typed Java Object from objectspace, to help pare down the possible matching objects to a manageable number. But they\u0026rsquo;re very similar when we look at them as object loading systems that accept reasonably fine-grained addressing information that identifies many things, but hopefully not lots of things.\nFinally, each of these systems is not a Java configuration system! But you know what is a configuration system, of a sort? java.util.ServiceLoader. It is a configuration system that just so happens to have punted the problem of resolving ambiguity to the end user. It is also designed to satisfy only one of several configuration-related use cases, which it does very well. What if we augmented ServiceLoader with the ability to receive some kind of addressing information that would allow it to avoid ambiguity in more cases than it does right now? What would we need to add?\nLoaders, Paths and Qualifiers First, let\u0026rsquo;s talk terminology. A configuration system doesn\u0026rsquo;t just load services, so we\u0026rsquo;ll drop that word. So ServiceLoader will become Loader for this discussion, and \u0026ldquo;service provider\u0026rdquo; will become \u0026ldquo;provider\u0026rdquo;, and so on.\nNext, we need a good word for our addressing information. We can look to JNDI and Jakarta RESTful web services here. In JNDI, the addressing information is termed a name. In Jakarta RESTful Web Services, the addressing information is termed a path (since of course it is concerned with URIs). I like path better than name for addressing information because it implies a type (a filesystem path yields a file, for example; a Jakarta RESTful Web Services path yields an object of a particular media type) and can either imply a tree structure or not, depending on how it\u0026rsquo;s used. It\u0026rsquo;s also about finding your way to a destination. So we\u0026rsquo;ll go with path.\nThe kind of path we\u0026rsquo;ll talk about is similar to Jakarta RESTful Web Services\u0026rsquo; path: it is sparse. That is, it\u0026rsquo;s not the case that every element in a path necessarily identifies an object at that location (in direct contrast with JNDI, where every atomic name in a compound name identifies a context). In this regard, a path is like a pointer or a probe: ultimately what matters is what it picks out at the end, not the intermediate objects that may exist along the way.\nOur path will also need to have the ability to pass additional addressing information. JNDI has environment properties. Jakarta RESTful Web Services provides resource methods with the ability to inspect headers, query string parameters, path parameters and matrix parameters. Each of these facilities is a way to further qualify a request. We\u0026rsquo;ll consequently follow in the terminological footsteps of systems like CDI and call this additional addressing information qualifiers.\nPutting it all together, a path is a typed and qualified ordered sequence of elements that identifies zero or more objects in objectspace.\nA loader is a component that dereferences a path.\nIf you look at things this way, then a java.util.ServiceLoader is a loader that dereferences very particular kinds of paths, namely those that have a type, zero elements and no qualifiers.\nWhat\u0026rsquo;s Next? We\u0026rsquo;re on our way, but we\u0026rsquo;re not there yet. What lies at the end of any path is not necessarily an object, but may be nothing or many objects. Also, since in the real world the objectspace we\u0026rsquo;re dealing with at any given time in any given system is actually fairly small and sparsely populated, we might want a strategy for what to do when a path doesn\u0026rsquo;t actually identify anything but something else might be suitable for it.\nAdditionally, even if a path does identify something, it may come and go over time, being temporarily or permanently absent or present. What our loader loads may therefore need to be not the object itself, but some kind of dereferencer that is pinned to the path that yielded it.\nThere is also the notion of an application\u0026rsquo;s environment to be concerned with. An application\u0026rsquo;s environment is the portion of objectspace it inhabits (the machine it lives on, the locale it\u0026rsquo;s in, various other automatic and implicit coordinates, and the human-authored configuration that is suitable for it), which includes parts that a component of that application, asking for an object to be loaded, is unaware of, but that are necessary to include with the addressing information. Other environments within objectspace may or may not be suitable for a loader to consider when trying to dereference a path.\nThe journey continues; stay tuned.\n","href":"/blog/service-loader-requests/","title":"Service Loader Requests"},{"content":" Table Of Contents  Background and Rationale Jakarta REST as a Configuration System?! The Foundation Configuration Concerns Disambiguation Suitability Conclusion    Background and Rationale I\u0026rsquo;ve written previously about looking at JNDI through a Java-centric configuration system design lens. Here I\u0026rsquo;ll do something similar with the JAX-RS specification (now known as {deep breath} Jakarta RESTful Web Services, or, hopefully soon, simply Jakarta REST, which is how I\u0026rsquo;ll refer to it in this article).\nJakarta REST as a Configuration System?! Hear me out.\nFirst, I\u0026rsquo;m not actually proposing that if you want a configuration framework in your Java program you should grab a Jakarta REST implementation and go to town.\nBut I am looking at it as primarily a Java framework, and not as something that is web-oriented. After all, one of its founding goals was to make it easy to use plain old Java objects (POJOs) to model representational state transfers. Who really cares if there is a network involved or not?\nThe Foundation Jakarta REST is built atop resource classes. While you should of course consult the specification for the official definition of resource classes (and anything else I\u0026rsquo;m going to wave my hands about in this article), the general gist is: a resource class is a POJO class with some specifically shaped methods in it, and annotated in a particular way.\nFor retrieval purposes (GET), which is all I\u0026rsquo;m interested in, methods that do retrievals obviously need to have a return type. The return type can be Jakarta-REST-specific (Response), or can be a POJO designed by the resource class designer.\nThe annotations on resource classes and their methods help them declare what paths they respond to, and what types of objects those methods supply in response.\nWhen you put this all together, you have a subsystem that receives a typed path, finds a relevant supplier (a resource method), caches that fact, and then uses that supplier to serve up an Object of some kind that corresponds to that path (and other qualifiers).\nConfiguration Concerns When you look at Jakarta REST this way, it starts to look an awful lot like some of the JNDI concepts I\u0026rsquo;ve written about previously.\nIn both cases there is a lookup operation, with name-like structures identifying the thing to retrieve. In both cases (although in JNDI it\u0026rsquo;s a pain in the neck) you can qualify your lookup. In both cases an application assembler can declare explicitly how bundles of components should be combined into an application in such a way that naming conflicts do not occur. In both cases, how a resulting Object is put together, or found, or synthesized, is completely transparent to the caller and is deliberately unspecified.\nJakarta REST also features a wealth of additional qualifiers that ride along with every request. You have the path, of course, but you also have headers (key/value pairs), MIME types, and request-level content negotiation strategies. If you look at these coarsely enough, they\u0026rsquo;re just qualifiers further picking out the Object that is being requested.\nOne of the nice things about the lookup request format that Jakarta REST uses is that in a path/with/many/components there is no presumption that each component in the path designates a retrievable resource. (JNDI, by contrast, basically requires that a Context exist at each juncture.) This allows for sparse graphs of resources, dynamic subresources, and all sorts of other interesting bits that end up being directly relevant to configuration systems.\nAnother nice thing about the lookup request format is that the incoming name-like structure (the request) consists not just of the name-like thing (the path) plus its qualifiers (the headers and matrix parameters and everything else) but also the type of the object being requested (expressed as a MIME type). In my earlier JNDI article, I noted that configuration systems involve a typed path at the heart of configuration lookup. JNDI sort of lets you get there, but it is awful and clunky to do. Jakarta REST makes it reasonably easy: by the time a resource method gets invoked, you know that MIME type matching has already occurred according to a well-specified algorithm, so you know that the resource method in question is equipped to service the request.\nDisambiguation Thankfully, the designers of Jakarta REST (well, JAX-RS, in this case) also realized the namespace issues that always show up when you talk about someone assembling components together into an application, and provided for their solution.\nIn JNDI, namespace issues are somewhat moot, because names are always relative to a Context: there\u0026rsquo;s no such thing as an absolute name. The same is not true in Jakarta REST, but the application assembler can explicitly designate an Application implementation that says for certain which Java classes are to be considered resource classes, and which are not. This allows two resource methods, for example, from two different sources, annotated with the same @Path annotation, to coexist: the application assembler can choose just one, can wrap the other, or any of a variety of other strategies at assembly time to resolve the ambiguity.\n(It\u0026rsquo;s worth noting that no Java-centric configuration system that I\u0026rsquo;m aware of lets you do this fundamental disambiguation operation at assembly time. That\u0026rsquo;s really odd.)\nSuitability Probably the most interesting feature of Jakarta REST when looked at through a Java-centric configuration lens is its built-in notion of suitability.\nA resource method is more or less suitable for a given request as specified by an exceedingly well-defined algorithm. For my purposes, the exact steps of the algorithm are unimportant. The fact that it exists and is defined in terms of application-level concerns, rather than component-level concerns is what is important. If this algorithm completes and there are somehow still two or more candidate resource methods for a given request, then an error is thrown. This means that resource method selection is deterministic: if you supply the same inputs, you get the same outputs every time.\nRecognizing the difference between application-level concerns and component-level concerns is critical for this kind of determinism, because components are often developed in isolation from one another, so sharing things like namespaces and numberspaces and pathspaces and all the rest can be difficult. So, for example, defining the matching algorithm in terms of a global set of MIME types means that there can be no name clashes between types: application/octet-stream means what it means, regardless of which component uses it.\nContrast this with another popular but extraordinarily misguided strategy of labeling some component somewhere with a numeric priority and believing erroneously that you have somehow solved the ambiguity problem. Instead, you\u0026rsquo;ve just punted it: If component A and component B are developed in isolation, and both have independently decided to declare that they are of priority 10, that is still a problem the application assembler has to solve, but unless there is yet another mechanism for her to disambiguiate this ambiguity, it can lead to a non-deterministic state of affairs. We see this, as I\u0026rsquo;ve noted earlier, in MicroProfile Config. (Interestingly, Jakarta REST did walk into this trap in terms of providers and other accessory entities, but at least they give the application assembler a welcome \u0026ldquo;out\u0026rdquo; since she can always write an Application class to make things more explicit.)\nConclusion Jakarta REST is a specification for web services, yes, but it is also a specification for acquiring Java Objects given path-like requests, where the potential suppliers of such Objects can be more or less suitable for any given request. This lines up pretty well with the requirements of a Java-centric configuration system. There are lessons to be learned here that can be applied to the design of a \u0026ldquo;real\u0026rdquo; Java-centric configuration system.\n","href":"/blog/java-configuration-jaxrs-as-a-configuration-system/","title":"Java Configuration: JAX-RS as a Configuration System"},{"content":"","href":"/tags/jaxrs/","title":"jaxrs"},{"content":" Table Of Contents  Background and Rationale What\u0026rsquo;s In A (Naming Service) Name?  The Object Management Group Naming Service Specification   JNDI  Bootstrapping Retrieval Operations Binding Operations Name-to-Object Bindings Synthesizing Operations  ObjectFactory   Event Operations   Putting It All Together JNDI Flaws  No Generics Binding and Lookup Services Colocated Vague Qualifiers Too Many Checked Exceptions Can\u0026rsquo;t Use Class or Type as a Selector Strange Service Provider Location Machinery Too Much Hierarchy   Conclusion What\u0026rsquo;s Next    Background and Rationale I\u0026rsquo;ve written previously about how Java configuration systems, boiled down to their essence, are simply systems for loading Java objects that are described in a particular way, usually by some kind of name (along with qualifiers), and that such systems have absolutely nothing to do with dependency injection or object binding or all the rest of the shiny but irrelevant things people like to get excited about in this space.\nThese ideas are not new. In the Java enterprise world, they first showed up in a systematic way in the Java Naming and Directory Interface (JNDI) API. This API, in turn, is a slight modernization, and idiomatic Java translation, of the Object Management Group\u0026rsquo;s Naming Service Specification, which quietly stagnated sometime in 2004.\nSomewhere along the line, JNDI got (wrongly) pigeonholed as just a way to access LDAP servers. I\u0026rsquo;m going to ignore that entire side of things (the \u0026ldquo;directory\u0026rdquo; part), because that\u0026rsquo;s not what JNDI primarily is at all.\nThen it got demonized because of the java: URL scheme and the comp/env naming prefix mandated by the Java EE Platform Specification to identify a component\u0026rsquo;s environment, but, as we\u0026rsquo;ll see, the concept underlying this prefix is critical, regardless of how clunky the actual implementation turned out to be.\nNow JNDI is routinely rejected more simply because of its age than because of any technical limitations it might have. Most people have no idea what it can do. Having said that, it most certainly does show its age, and not in a good way.\nSo why would we look at all this? Because to this day it is the only Java-related configuration-like system that has appropriately considered most, if not all, the concerns that arise when you talk about loading Java objects that are qualified in some way into a class—the very heart of Java-centric configuration use cases:\n It accounts for name collisions. It has symbolic links. It allows for user-supplied name resolution mechanisms. It allows for user-supplied namespaces. It permits qualifiers to help describe a lookup. It does not mandate an object binding strategy.  It\u0026rsquo;s somewhat bizarre to note that the Java-centric configuration frameworks currently en vogue are so comparatively deficient:\n  MicroProfile Config certainly has not considered these concerns. (As I\u0026rsquo;ve written before, it is non-deterministic and subject to namespace clashes.)\n  Lightbend\u0026rsquo;s TypeSafe Config has not considered these concerns. (Names are considered to be absolute.)\n  Spring has not considered these concerns. (Names are considered to be absolute and configured objects are presumed to \u0026ldquo;belong\u0026rdquo; to the Spring ecosystem.)\n  Jakarta Config is stumbling backwards into these concerns without realizing they are valid concerns, and is repeating the egregious mistakes of MicroProfile Config before it. (It is non-deterministic and subject to namespace clashes and is focusing its standardization efforts in irrelevant places.)\n  I\u0026rsquo;m sure there are others.\nWhat if we could extract the age-old lookup-and-namespace-related concerns that JNDI addresses and re-express them with a modern API? That would make for a pretty decent Java-centric configuration API.\nTo catch a glimpse of these concerns and how they are addressed within JNDI requires a little bit of squinting. The JNDI API itself is old and outdated by today\u0026rsquo;s standards. It predates generics, for one thing, and attempts to modernize it, regardless of how trivial, have been gently and officially rebuffed. For another, it predates the java.util.ServiceLoader convention of discovering service providers at startup. It is, in short, a pain in the neck to work with.\nGetting past these anachronisms and others like them can be a little tricky, but the journey is worth it.\nWhat\u0026rsquo;s In A (Naming Service) Name? Let\u0026rsquo;s talk about what a naming service does, and why the terms even exist, and, as a result, why no one ever thinks of \u0026ldquo;naming service\u0026rdquo; in the same breath as \u0026ldquo;configuration\u0026rdquo; (but maybe they should).\nFirst, we\u0026rsquo;ll talk about JNDI\u0026rsquo;s precursor, the Object Management Group\u0026rsquo;s Naming Service Specification. I know: CORBA—but bear with me.\nThe Object Management Group Naming Service Specification Let\u0026rsquo;s revisit the 1990s for a moment. How do you do, fellow kids?\nBack in CORBA\u0026rsquo;s day, you could park distributed objects on one machine, and use another machine to look them up, and the calling program might be written in an entirely different language from the serving program. The sub-programs doing the actual retrieval and serving were known as ORBs: object request brokers. As you might imagine, an object request broker turns a simple local request for a particular object into a distributed request for that object, and answers such remote requests as well.\nBecause CORBA is cross-language, this meant that each ORB had to be able to park an object under some kind of location that any requestor could specify in some way, regardless of the languages involved. All languages have strings, and CORBA had ironed out the various language- and machine-related discrepancies among strings, so the way you identified the object you wanted to retrieve from some other ORB was to effectively just name it. So a naming service, then, is something that, when given a string-typed, address-like name of some kind, gives you back an object bound under that name, suitable for immediate use in the calling language. (Usually there was a hazy presumption that something remote-ish had occurred, e.g. you had retrieved an object over the network from some other machine somewhere. This was because so-called distributed objects were cool. Now we know better, but the (mostly valid) concepts involved apply even locally, as we\u0026rsquo;ll see.)\n(More importantly for configuration-related purposes, a name\u0026rsquo;s sole function, really, is to help distinguish one typed object from another object bearing the same type.)\nGetting ORBs from different vendors to cooperate was tough, so there were a lot of specifications that ended up being written by the Object Management Group. One of them was a specification governing hierarchical naming semantics, named, appropriately enough, the Naming Service Specification.\nThere\u0026rsquo;s nothing that says, inherently, that a naming service has to be hierarchical. But hierarchies can be convenient, and the Naming Service Specification decided to formally specify tree-based naming semantics instead of flat ones. The root of a naming service tree is a context; its nodes are objects; its branches are names.\n(A context, of course, is also a kind of object, and again, while specifying the notion of a child context is not required, that\u0026rsquo;s how the Naming Service Specification decided to do it.)\n(Some of this hierarchical stuff was due to the inherent chattiness of CORBA itself: you didn\u0026rsquo;t want to traverse deep graphs with remote calls for each traversal operation! Better to grab a context and use it directly to get its stuff.)\nAmong other things, all of this means that, in the Naming Service Specification, any given name is always relative to a parent context. There are no absolute names. If I give you a name, you don\u0026rsquo;t know what it means or designates (in the absence of other information). But if I tell you that it\u0026rsquo;s relative to a particular context, then you have the tools to be able to resolve the name against that context and find the object it points to. A context turns out to be a namespace (among other things).\n(In the world of name-based configuration this concept is absolutely critical. It is ignored by all major Java-centric configuration frameworks for no good reason that I can see.)\nIn the Naming Service Specification, names have structure. A sequence of components within a name forms a compound name. Its individual components are also known as simple names. Finally, if you have a compound name with two components (simple names), there is also one context involved: the one that the first component desginates, and to which the second component is relative. (To belabor an earlier point, note that the first component (simple name) is relative to some context but in this example I haven\u0026rsquo;t told you what it is, so, standing on its own, this hypothetical compound name is rather useless.)\nThe Naming Service Specification also gestures feebly at another type of identifier that is sort of part of names: kind. It reads, in part:\n The kind attribute adds descriptive power to names in a syntax-independent way. Examples of the value of the kind attribute include c_source, object_code, executable, postscript, or “ ”. The naming system does not interpret, assign, or manage these values in any way. Higher levels of software may make policies about the use and management of these values. This feature addresses the needs of applications that use syntactic naming conventions to distinguish related objects. For example Unix uses suffixes such as .c and .o. Applications (such as the C compiler) depend on these syntactic convention to make name transformations (for example, to transform foo.c to foo.o).\n (This reads as a kind of primitive precursor to MIME types. It also demonstrates, inadvertently, that any system that uses a \u0026ldquo;name\u0026rdquo; to look something up eventually realizes that it must use qualifiers to look something up instead. JAX-RS matrix parameters, and HTTP headers, are other examples of this sort of thing. There\u0026rsquo;s plenty more to say about this, but not here.)\nJNDI JNDI\u0026rsquo;s naming services are a very straightforward translation of the language-independent terminology of the Naming Service Specification into relatively idiomatic Java terms.\nJNDI, like the Naming Service Specification, has a Context, which, like its namesake, is a locus of Names that designate Objects (including other Contexts). (A Context belongs to a naming system, which is a conceptual entity seemingly introduced by the JNDI specification and not really present in the Naming Service Specification.)\nJNDI\u0026rsquo;s Names are like those of the Naming Service Specification, but do not explicitly include the concept of simple names. Instead, a JNDI name is always either a compound name, even if it has only one component, or a composite name, a term not mentioned in the Naming Service Specification. (Composite names were added in a JNDI specification revision, and allow a single name to automatically span actual naming systems, with sophisticated parsing semantics.) Within any given naming system, hierarchical or flat, you\u0026rsquo;re always working with compound names.\nLike the Naming Service Specification, any given JNDI Name is always relative to a parent Context.\nBootstrapping JNDI allows an implementor to bootstrap itself. This is fairly unique, even today.\nSpecifically, the InitialContext class is just a Context implementation that finds a \u0026ldquo;real\u0026rdquo; Context implementation to use, and then delegates all operations to it. The JNDI bootstrap mechanism, which predates the java.util.ServiceLoader service provider approach but which seems to have served as its inspiration, allows custom InitialContext implementations to be supplied from outside of the framework.\nThis means, among other things, the Context to which primordial Names are relative is highly customizable, even by end users.\nIn today\u0026rsquo;s Java world, someone would probably have introduced (needlessly) a builder-style object, or a whole scaffolding framework for finding the root Context. In JNDI, you just call new InitialContext() and you\u0026rsquo;re done, as it should be.\nRetrieval Operations From the looking-things-up perspective, that\u0026rsquo;s about it. Get your hands on a Context, ask it for an Object under a particular Name, and make use of the resulting Object. Where the Object came from, how it was bound, whether it was synthesized out of other Objects, whether various kinds of links and redirects were followed, whether the Object fronts some other kind of system—none of these things are your concern. You named an Object, you resolved that name against a Context, and you took delivery of that Object.\nOf particular note, you probably also cast that Object to a type you were expecting. More on that later. Peeking ahead for a moment, a name always has a conceptual type that the caller, for the most part, is expecting.\nBinding Operations Since JNDI emerged from the CORBA world and was a faithful carryover of the Naming Service Specification, it also handled the \u0026ldquo;writing side\u0026rdquo; of naming services. Placing an Object under a Name in JNDI is known as binding. For my purposes, I\u0026rsquo;ll be ignoring all binding operations. Java EE, in fact, one of the earliest consumers of JNDI, required that Contexts exposed to the end user be read-only, and it\u0026rsquo;s a regrettable fact (in my opinion) that the mutating operations of JNDI were not split into their own sub-specification.\nName-to-Object Bindings For ordinary use cases, a Name in JNDI is always conceptually bound to some kind of Object. This means that a Name, regardless of how many components it might have, also has an effective (Java) type, namely, that of the Object that it references.\nJNDI has a few clunky introspective APIs for listing bindings, but for my purposes I\u0026rsquo;m going to ignore them, since in configuration use cases you already know the name of the thing you\u0026rsquo;re looking up. What\u0026rsquo;s mainly important here is that a Name, when resolved against a Context, is effectively typed by a Java class.\nSynthesizing Operations JNDI has a facility, not found in the Naming Service Specification, that permits some other Java object to synthesize a Java object out of \u0026ldquo;raw materials\u0026rdquo;, any of which may be bound in a tree rooted at any Context. This object doing the synthesizing is called an ObjectFactory. A JNDI implementation itself can supply ObjectFactory instances, but, more importantly for this article\u0026rsquo;s purposes, so can users and component providers.\nThis sounds complicated but is actually fairly simple.\nRecall that when you look something up in a JNDI tree rooted under a Context, you are blissfully unaware of the name resolution process (how the Object that is eventually delivered to you came to exist). Was it put together out of other things? Was it created out of nothing? Was it loaded from disk? Served over the network? You don\u0026rsquo;t know and you don\u0026rsquo;t care.\nFor certain cases, name resolution is absurdly simple: someone explicitly bound a textual string into a Context under, say, the name \u0026ldquo;hoopy\u0026rdquo;; you asked for the Object bound under \u0026ldquo;hoopy\u0026rdquo;; and lo and behold you got back that very string—perhaps \u0026ldquo;frood\u0026quot;—as a Java String object. Nothing fancy here.\nObjectFactory In other cases, an ObjectFactory gets involved. This happens because the Context::lookup operation delegates, in all implementations that I\u0026rsquo;m aware of, and perhaps explicitly stated somewhere, to a call to the NamingManager::getObjectInstance method, which pulls in ObjectFactory instances to actually perform the creation (or retrieval, or synthesis, or whatever) of a Java Object for a given Name.\nSo backing up from the minutiae for a moment, depending on what ObjectFactory instances are on the classpath and properly designated, a JNDI implementation may synthesize Objects out of thin air as if they were bound explicitly to various Names.\nObjectFactory instances and explicit binding can work together, too. An administrator can bind a Reference into a JNDI implementation that explicitly names the ObjectFactory to use to perform the actual name resolution.\nURL Context Factory One kind of ObjectFactory is one that plays the role of a URL context factory. These kinds of ObjectFactory implementations can create Contexts to represent particular URL schemes, such as, most infamously, java:, which is at the heart of the Java EE (and now Jakarta EE) specifications.\nThe notorious java:comp/env \u0026ldquo;prefix\u0026rdquo; is, more specifically, a URL whose semantics are strictly defined by the Java EE (now Jakarta EE) Platform Specification. java: causes a URL context factory specified by the Platform Specification to come into the picture, and comp/env is a compound name, relative to the root Context created by the URL context factory, denoting, by definition, a Context with very specific semantics. One of its specific semantics is very interesting to configuration systems, because it disambiguates component namespaces. That is, if an EJB refers to a Frood stored under the name hoopy, and another EJB refers to a Towel stored under the name hoopy, no conflict can occur, so long as hoopy is relative to java:comp/env in both cases.\nNo Java-centric configuration framework that I\u0026rsquo;m aware of other than JNDI addresses this extremely important concern.\nEvent Operations JNDI features events that can be fired when a bound object changes, or when an object has been added or removed.\nPutting It All Together So backing up to the conceptual level, JNDI provides the ability for two names to be used by two different components developed in isolation to refer to two different things, with at least the possibility that a name clash will not occur (one component\u0026rsquo;s java:comp/env Context is not the same Context as another component\u0026rsquo;s java:comp/env Context).\nIn addition, it allows for user-supplied factories to handle individual name resolution operations. There is a defined search order for discovering such factories. You supply a name, the system searches until it finds something that can make Objects for that name.\nJNDI properly separates the lookup use cases (ask for an Object of a particular type by name; receive it) from the binding and administration use cases (install an ObjectFactory that knows how to make an Object of a particular type; bind that ObjectFactory to a particular name), to such a degree that there could have been two specifications instead of one.\nOperations such as conversion and object binding are deliberately left unspecified, as it should be. That is, any given ObjectFactory may do whatever it wishes to come up with an Object for a given name resolution request.\nAt an abstract level, a compound name is a typed path, whose intermediate nodes may have known types as well.\nIf we strip some of the terminology and API cruft away we can say the following:\n In JNDI and configuration systems, there is some kind of root object to which notional paths are relative.  In JNDI this is a Context and the rootiest of all root Contexts is an InitialContext, as the name accurately reflects.   In JNDI and configuration systems, you locate an Object by supplying that root object with a typed path that designates the Object to retrieve.  In JNDI this is a CompoundName supplied to the Context::lookup method, and if you need to figure out what the type is, you can invoke any of several crufty methods to find the relevant Class.   In JNDI and configuration systems, some accessory piece of technology that is registered under that typed path is actually responsible for making the requested Object come into existence.  In JNDI, this is an ObjectFactory invoked by way of the NamingManager::getObjectInstance method.    JNDI Flaws So is JNDI the hipster configuration system that has been hiding in plain sight? Yes and no.\nWe\u0026rsquo;ve seen that it gets the separation of concerns right, and that its lookup features are relatively simple, and that it is unique among configuration systems in understanding the importance of namespaces. But there are plenty of problems.\nNo Generics First of all, in modern Java, you may not be looking for a List under a specific name, but a List\u0026lt;String\u0026gt;. JNDI predates generics, so you\u0026rsquo;ll have to do a lot of casting when you use this API.\nBinding and Lookup Services Colocated Next, a Context has a rather large number of methods because the lookup and binding services were combined into one interface. In hindsight, this was a mistake.\nVague Qualifiers Context instances have the ability to have \u0026ldquo;environments\u0026rdquo;, which are Hashtables (yes, Hashtables; JNDI predates the collections APIs) but whose purpose is left vague. Like any specification that features an untyped bag of named properties, this is usually a sign that some aspect of the problem domain wasn\u0026rsquo;t really understood too well.\nIf you look at it one way, a Context\u0026rsquo;s environment is really additional qualifiers qualifying lookups. For configuration system purposes, this concept, which I\u0026rsquo;ve argued is necessary, needs to be tightened up a little bit.\nToo Many Checked Exceptions JNDI was created when checked exceptions were all the rage. This makes using it in today\u0026rsquo;s Java projects laborious and unpleasant. Easy use cases, like using a default value in case a bound value is not present, are quite difficult as a result.\nCan\u0026rsquo;t Use Class or Type as a Selector The fact that it is a Name, and not some other kind of key, that is used to select Objects is mostly arbitrary and rooted in CORBA\u0026rsquo;s distributed objects background. For Java-centric configuration systems, what matters most of the time is the type of Object the caller is seeking. Names in this use case are secondary and used mostly to disambiguate, for example, one kind of Frood from another kind of Frood (perhaps the caller wants the hoopy Frood and not the unnamed Frood). JNDI requires that there be names for everything, even where they are superfluous.\nStrange Service Provider Location Machinery JNDI predates the java.util.ServiceLoader class, so it\u0026rsquo;s no surprise that its mechanism for finding service provider classes is a bit arcane.\nToo Much Hierarchy As noted earlier, for configuration system purposes, a tree model is not necessary. In most specifications, if you find that something is not necessary, you leave it out. There doesn\u0026rsquo;t seem to be a need for there to be an intermediate Context \u0026ldquo;in between\u0026rdquo; any two name components, but it fit a mental model the Naming Service Specification authors were familiar with, and JNDI tracked that specification, so here we are.\nConclusion JNDI is an old and clunky API with solid conceptual underpinnings that addresses most, if not all, concerns that any Java-centric configuration system will encounter. It is worth using as a kind of rubric to check any configuration system implementation against for correctness.\nWhat\u0026rsquo;s Next In a future post, I hope to write about JAX-RS from a Java-centric configuration system perspective. Seen through this lens, JAX-RS is a very interesting system for acquiring Java Objects based on a combination of names and qualifiers and MIME types, auto-discovering providers and negotiating and resolving ambiguities. If you combine its concepts with JNDI\u0026rsquo;s notion of namespaces and self-bootstrapping, a design for a Java-centric configuration system falls out rather easily.\n","href":"/blog/java-configuration-jndi-and-naming-operations/","title":"Java Configuration: JNDI and Naming Operations"},{"content":"","href":"/tags/jndi/","title":"jndi"},{"content":"","href":"/tags/personal/","title":"personal"},{"content":"Hello and welcome to my new blog.\nMy old blog is still available.\n","href":"/blog/welcome/","title":"Welcome"},{"content":"Older Posts There is a prior version of this blog that contains my older posts.\nRecent Posts Recent posts may be found below.\n","href":"/blog/","title":"Blog"},{"content":"","href":"/authors/","title":"Authors"},{"content":"","href":"/categories/","title":"Categories"},{"content":"","href":"/page/","title":"Pages"},{"content":"","href":"/search/","title":"Search"},{"content":"","href":"/series/","title":"Series"}]
