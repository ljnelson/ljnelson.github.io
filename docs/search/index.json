[{"content":"","href":"/","title":"Home"},{"content":"","href":"/tags/config/","title":"config"},{"content":"","href":"/tags/java/","title":"java"},{"content":" Table Of Contents  Background and Rationale Jakarta REST as a Configuration System?! The Foundation Configuration Concerns Disambiguation Suitability Conclusion    Background and Rationale I\u0026rsquo;ve written previously about looking at JNDI through a Java-centric configuration system design lens. Here I\u0026rsquo;ll do something similar with the JAX-RS specification (now known as {deep breath} Jakarta RESTful Web Services, or, hopefully soon, simply Jakarta REST, which is how I\u0026rsquo;ll refer to it in this article).\nJakarta REST as a Configuration System?! Hear me out.\nFirst, I\u0026rsquo;m not actually proposing that if you want a configuration framework in your Java program you should grab a Jakarta REST implementation and go to town.\nBut I am looking at it as primarily a Java framework, and not as something that is web-oriented. After all, one of its founding goals was to make it easy to use plain old Java objects (POJOs) to model representational state transfers. Who really cares if there is a network involved or not?\nThe Foundation Jakarta REST is built atop resource classes. While you should of course consult the specification for the official definition of resource classes (and anything else I\u0026rsquo;m going to wave my hands about in this article), the general gist is: a resource class is a POJO class with some specifically shaped methods in it, and annotated in a particular way.\nFor retrieval purposes (GET), which is all I\u0026rsquo;m interested in, methods that do retrievals obviously need to have a return type. The return type can be Jakarta-REST-specific (Response), or can be a POJO designed by the resource class designer.\nThe annotations on resource classes and their methods help them declare what paths they respond to, and what types of objects those methods supply in response.\nWhen you put this all together, you have a subsystem that receives a typed path, finds a relevant supplier (a resource method), caches that fact, and then uses that supplier to serve up an Object of some kind that corresponds to that path (and other qualifiers).\nConfiguration Concerns When you look at Jakarta REST this way, it starts to look an awful lot like some of the JNDI concepts I\u0026rsquo;ve written about previously.\nIn both cases there is a lookup operation, with name-like structures identifying the thing to retrieve. In both cases (although in JNDI it\u0026rsquo;s a pain in the neck) you can qualify your lookup. In both cases an application assembler can declare explicitly how bundles of components should be combined into an application in such a way that naming conflicts do not occur. In both cases, how a resulting Object is put together, or found, or synthesized, is completely transparent to the caller and is deliberately unspecified.\nJakarta REST also features a wealth of additional qualifiers that ride along with every request. You have the path, of course, but you also have headers (key/value pairs), MIME types, and request-level content negotiation strategies. If you look at these coarsely enough, they\u0026rsquo;re just qualifiers further picking out the Object that is being requested.\nOne of the nice things about the lookup request format that Jakarta REST uses is that in a path/with/many/components there is no presumption that each component in the path designates a retrievable resource. (JNDI, by contrast, basically requires that a Context exist at each juncture.) This allows for sparse graphs of resources, dynamic subresources, and all sorts of other interesting bits that end up being directly relevant to configuration systems.\nAnother nice thing about the lookup request format is that the incoming name-like structure (the request) consists not just of the name-like thing (the path) plus its qualifiers (the headers and matrix parameters and everything else) but also the type of the object being requested (expressed as a MIME type). In my earlier JNDI article, I noted that configuration systems involve a typed path at the heart of configuration lookup. JNDI sort of lets you get there, but it is awful and clunky to do. Jakarta REST makes it reasonably easy: by the time a resource method gets invoked, you know that MIME type matching has already occurred according to a well-specified algorithm, so you know that the resource method in question is equipped to service the request.\nDisambiguation Thankfully, the designers of Jakarta REST (well, JAX-RS, in this case) also realized the namespace issues that always show up when you talk about someone assembling components together into an application, and provided for their solution.\nIn JNDI, namespace issues are somewhat moot, because names are always relative to a Context: there\u0026rsquo;s no such thing as an absolute name. The same is not true in Jakarta REST, but the application assembler can explicitly designate an Application implementation that says for certain which Java classes are to be considered resource classes, and which are not. This allows two resource methods, for example, from two different sources, annotated with the same @Path annotation, to coexist: the application assembler can choose just one, can wrap the other, or any of a variety of other strategies at assembly time to resolve the ambiguity.\n(It\u0026rsquo;s worth noting that no Java-centric configuration system that I\u0026rsquo;m aware of lets you do this fundamental disambiguation operation at assembly time. That\u0026rsquo;s really odd.)\nSuitability Probably the most interesting feature of Jakarta REST when looked at through a Java-centric configuration lens is its built-in notion of suitability.\nA resource method is more or less suitable for a given request as specified by an exceedingly well-defined algorithm. For my purposes, the exact steps of the algorithm are unimportant. The fact that it exists and is defined in terms of application-level concerns, rather than component-level concerns is what is important. If this algorithm completes and there are somehow still two or more candidate resource methods for a given request, then an error is thrown. This means that resource method selection is deterministic: if you supply the same inputs, you get the same outputs every time.\nRecognizing the difference between application-level concerns and component-level concerns is critical for this kind of determinism, because components are often developed in isolation from one another, so sharing things like namespaces and numberspaces and pathspaces and all the rest can be difficult. So, for example, defining the matching algorithm in terms of a global set of MIME types means that there can be no name clashes between types: application/octet-stream means what it means, regardless of which component uses it.\nContrast this with another popular but extraordinarily misguided strategy of labeling some component somewhere with a numeric priority and believing erroneously that you have somehow solved the ambiguity problem. Instead, you\u0026rsquo;ve just punted it: If component A and component B are developed in isolation, and both have independently decided to declare that they are of priority 10, that is still a problem the application assembler has to solve, but unless there is yet another mechanism for her to disambiguiate this ambiguity, it can lead to a non-deterministic state of affairs. We see this, as I\u0026rsquo;ve noted earlier, in MicroProfile Config. (Interestingly, Jakarta REST did walk into this trap in terms of providers and other accessory entities, but at least they give the application assembler a welcome \u0026ldquo;out\u0026rdquo; since she can always write an Application class to make things more explicit.)\nConclusion Jakarta REST is a specification for web services, yes, but it is also a specification for acquiring Java Objects given path-like requests, where the potential suppliers of such Objects can be more or less suitable for any given request. This lines up pretty well with the requirements of a Java-centric configuration system. There are lessons to be learned here that can be applied to the design of a \u0026ldquo;real\u0026rdquo; Java-centric configuration system.\n","href":"/blog/java-configuration-jaxrs-as-a-configuration-system/","title":"Java Configuration: JAX-RS as a Configuration System"},{"content":"","href":"/tags/jaxrs/","title":"jaxrs"},{"content":"","href":"/tags/","title":"Tags"},{"content":" Table Of Contents  Background and Rationale What\u0026rsquo;s In A (Naming Service) Name?  The Object Management Group Naming Service Specification   JNDI  Bootstrapping Retrieval Operations Binding Operations Name-to-Object Bindings Synthesizing Operations  ObjectFactory   Event Operations   Putting It All Together JNDI Flaws  No Generics Binding and Lookup Services Colocated Vague Qualifiers Too Many Checked Exceptions Can\u0026rsquo;t Use Class or Type as a Selector Strange Service Provider Location Machinery Too Much Hierarchy   Conclusion What\u0026rsquo;s Next    Background and Rationale I\u0026rsquo;ve written previously about how Java configuration systems, boiled down to their essence, are simply systems for loading Java objects that are described in a particular way, usually by some kind of name (along with qualifiers), and that such systems have absolutely nothing to do with dependency injection or object binding or all the rest of the shiny but irrelevant things people like to get excited about in this space.\nThese ideas are not new. In the Java enterprise world, they first showed up in a systematic way in the Java Naming and Directory Interface (JNDI) API. This API, in turn, is a slight modernization, and idiomatic Java translation, of the Object Management Group\u0026rsquo;s Naming Service Specification, which quietly stagnated sometime in 2004.\nSomewhere along the line, JNDI got (wrongly) pigeonholed as just a way to access LDAP servers. I\u0026rsquo;m going to ignore that entire side of things (the \u0026ldquo;directory\u0026rdquo; part), because that\u0026rsquo;s not what JNDI primarily is at all.\nThen it got demonized because of the java: URL scheme and the comp/env naming prefix mandated by the Java EE Platform Specification to identify a component\u0026rsquo;s environment, but, as we\u0026rsquo;ll see, the concept underlying this prefix is critical, regardless of how clunky the actual implementation turned out to be.\nNow JNDI is routinely rejected more simply because of its age than because of any technical limitations it might have. Most people have no idea what it can do. Having said that, it most certainly does show its age, and not in a good way.\nSo why would we look at all this? Because to this day it is the only Java-related configuration-like system that has appropriately considered most, if not all, the concerns that arise when you talk about loading Java objects that are qualified in some way into a class—the very heart of Java-centric configuration use cases:\n It accounts for name collisions. It has symbolic links. It allows for user-supplied name resolution mechanisms. It allows for user-supplied namespaces. It permits qualifiers to help describe a lookup. It does not mandate an object binding strategy.  It\u0026rsquo;s somewhat bizarre to note that the Java-centric configuration frameworks currently en vogue are so comparatively deficient:\n  MicroProfile Config certainly has not considered these concerns. (As I\u0026rsquo;ve written before, it is non-deterministic and subject to namespace clashes.)\n  Lightbend\u0026rsquo;s TypeSafe Config has not considered these concerns. (Names are considered to be absolute.)\n  Spring has not considered these concerns. (Names are considered to be absolute and configured objects are presumed to \u0026ldquo;belong\u0026rdquo; to the Spring ecosystem.)\n  Jakarta Config is stumbling backwards into these concerns without realizing they are valid concerns, and is repeating the egregious mistakes of MicroProfile Config before it. (It is non-deterministic and subject to namespace clashes and is focusing its standardization efforts in irrelevant places.)\n  I\u0026rsquo;m sure there are others.\nWhat if we could extract the age-old lookup-and-namespace-related concerns that JNDI addresses and re-express them with a modern API? That would make for a pretty decent Java-centric configuration API.\nTo catch a glimpse of these concerns and how they are addressed within JNDI requires a little bit of squinting. The JNDI API itself is old and outdated by today\u0026rsquo;s standards. It predates generics, for one thing, and attempts to modernize it, regardless of how trivial, have been gently and officially rebuffed. For another, it predates the java.util.ServiceLoader convention of discovering service providers at startup. It is, in short, a pain in the neck to work with.\nGetting past these anachronisms and others like them can be a little tricky, but the journey is worth it.\nWhat\u0026rsquo;s In A (Naming Service) Name? Let\u0026rsquo;s talk about what a naming service does, and why the terms even exist, and, as a result, why no one ever thinks of \u0026ldquo;naming service\u0026rdquo; in the same breath as \u0026ldquo;configuration\u0026rdquo; (but maybe they should).\nFirst, we\u0026rsquo;ll talk about JNDI\u0026rsquo;s precursor, the Object Management Group\u0026rsquo;s Naming Service Specification. I know: CORBA—but bear with me.\nThe Object Management Group Naming Service Specification Let\u0026rsquo;s revisit the 1990s for a moment. How do you do, fellow kids?\nBack in CORBA\u0026rsquo;s day, you could park distributed objects on one machine, and use another machine to look them up, and the calling program might be written in an entirely different language from the serving program. The sub-programs doing the actual retrieval and serving were known as ORBs: object request brokers. As you might imagine, an object request broker turns a simple local request for a particular object into a distributed request for that object, and answers such remote requests as well.\nBecause CORBA is cross-language, this meant that each ORB had to be able to park an object under some kind of location that any requestor could specify in some way, regardless of the languages involved. All languages have strings, and CORBA had ironed out the various language- and machine-related discrepancies among strings, so the way you identified the object you wanted to retrieve from some other ORB was to effectively just name it. So a naming service, then, is something that, when given a string-typed, address-like name of some kind, gives you back an object bound under that name, suitable for immediate use in the calling language. (Usually there was a hazy presumption that something remote-ish had occurred, e.g. you had retrieved an object over the network from some other machine somewhere. This was because so-called distributed objects were cool. Now we know better, but the (mostly valid) concepts involved apply even locally, as we\u0026rsquo;ll see.)\n(More importantly for configuration-related purposes, a name\u0026rsquo;s sole function, really, is to help distinguish one typed object from another object bearing the same type.)\nGetting ORBs from different vendors to cooperate was tough, so there were a lot of specifications that ended up being written by the Object Management Group. One of them was a specification governing hierarchical naming semantics, named, appropriately enough, the Naming Service Specification.\nThere\u0026rsquo;s nothing that says, inherently, that a naming service has to be hierarchical. But hierarchies can be convenient, and the Naming Service Specification decided to formally specify tree-based naming semantics instead of flat ones. The root of a naming service tree is a context; its nodes are objects; its branches are names.\n(A context, of course, is also a kind of object, and again, while specifying the notion of a child context is not required, that\u0026rsquo;s how the Naming Service Specification decided to do it.)\n(Some of this hierarchical stuff was due to the inherent chattiness of CORBA itself: you didn\u0026rsquo;t want to traverse deep graphs with remote calls for each traversal operation! Better to grab a context and use it directly to get its stuff.)\nAmong other things, all of this means that, in the Naming Service Specification, any given name is always relative to a parent context. There are no absolute names. If I give you a name, you don\u0026rsquo;t know what it means or designates (in the absence of other information). But if I tell you that it\u0026rsquo;s relative to a particular context, then you have the tools to be able to resolve the name against that context and find the object it points to. A context turns out to be a namespace (among other things).\n(In the world of name-based configuration this concept is absolutely critical. It is ignored by all major Java-centric configuration frameworks for no good reason that I can see.)\nIn the Naming Service Specification, names have structure. A sequence of components within a name forms a compound name. Its individual components are also known as simple names. Finally, if you have a compound name with two components (simple names), there is also one context involved: the one that the first component desginates, and to which the second component is relative. (To belabor an earlier point, note that the first component (simple name) is relative to some context but in this example I haven\u0026rsquo;t told you what it is, so, standing on its own, this hypothetical compound name is rather useless.)\nThe Naming Service Specification also gestures feebly at another type of identifier that is sort of part of names: kind. It reads, in part:\n The kind attribute adds descriptive power to names in a syntax-independent way. Examples of the value of the kind attribute include c_source, object_code, executable, postscript, or “ ”. The naming system does not interpret, assign, or manage these values in any way. Higher levels of software may make policies about the use and management of these values. This feature addresses the needs of applications that use syntactic naming conventions to distinguish related objects. For example Unix uses suffixes such as .c and .o. Applications (such as the C compiler) depend on these syntactic convention to make name transformations (for example, to transform foo.c to foo.o).\n (This reads as a kind of primitive precursor to MIME types. It also demonstrates, inadvertently, that any system that uses a \u0026ldquo;name\u0026rdquo; to look something up eventually realizes that it must use qualifiers to look something up instead. JAX-RS matrix parameters, and HTTP headers, are other examples of this sort of thing. There\u0026rsquo;s plenty more to say about this, but not here.)\nJNDI JNDI\u0026rsquo;s naming services are a very straightforward translation of the language-independent terminology of the Naming Service Specification into relatively idiomatic Java terms.\nJNDI, like the Naming Service Specification, has a Context, which, like its namesake, is a locus of Names that designate Objects (including other Contexts). (A Context belongs to a naming system, which is a conceptual entity seemingly introduced by the JNDI specification and not really present in the Naming Service Specification.)\nJNDI\u0026rsquo;s Names are like those of the Naming Service Specification, but do not explicitly include the concept of simple names. Instead, a JNDI name is always either a compound name, even if it has only one component, or a composite name, a term not mentioned in the Naming Service Specification. (Composite names were added in a JNDI specification revision, and allow a single name to automatically span actual naming systems, with sophisticated parsing semantics.) Within any given naming system, hierarchical or flat, you\u0026rsquo;re always working with compound names.\nLike the Naming Service Specification, any given JNDI Name is always relative to a parent Context.\nBootstrapping JNDI allows an implementor to bootstrap itself. This is fairly unique, even today.\nSpecifically, the InitialContext class is just a Context implementation that finds a \u0026ldquo;real\u0026rdquo; Context implementation to use, and then delegates all operations to it. The JNDI bootstrap mechanism, which predates the java.util.ServiceLoader service provider approach but which seems to have served as its inspiration, allows custom InitialContext implementations to be supplied from outside of the framework.\nThis means, among other things, the Context to which primordial Names are relative is highly customizable, even by end users.\nIn today\u0026rsquo;s Java world, someone would probably have introduced (needlessly) a builder-style object, or a whole scaffolding framework for finding the root Context. In JNDI, you just call new InitialContext() and you\u0026rsquo;re done, as it should be.\nRetrieval Operations From the looking-things-up perspective, that\u0026rsquo;s about it. Get your hands on a Context, ask it for an Object under a particular Name, and make use of the resulting Object. Where the Object came from, how it was bound, whether it was synthesized out of other Objects, whether various kinds of links and redirects were followed, whether the Object fronts some other kind of system—none of these things are your concern. You named an Object, you resolved that name against a Context, and you took delivery of that Object.\nOf particular note, you probably also cast that Object to a type you were expecting. More on that later. Peeking ahead for a moment, a name always has a conceptual type that the caller, for the most part, is expecting.\nBinding Operations Since JNDI emerged from the CORBA world and was a faithful carryover of the Naming Service Specification, it also handled the \u0026ldquo;writing side\u0026rdquo; of naming services. Placing an Object under a Name in JNDI is known as binding. For my purposes, I\u0026rsquo;ll be ignoring all binding operations. Java EE, in fact, one of the earliest consumers of JNDI, required that Contexts exposed to the end user be read-only, and it\u0026rsquo;s a regrettable fact (in my opinion) that the mutating operations of JNDI were not split into their own sub-specification.\nName-to-Object Bindings For ordinary use cases, a Name in JNDI is always conceptually bound to some kind of Object. This means that a Name, regardless of how many components it might have, also has an effective (Java) type, namely, that of the Object that it references.\nJNDI has a few clunky introspective APIs for listing bindings, but for my purposes I\u0026rsquo;m going to ignore them, since in configuration use cases you already know the name of the thing you\u0026rsquo;re looking up. What\u0026rsquo;s mainly important here is that a Name, when resolved against a Context, is effectively typed by a Java class.\nSynthesizing Operations JNDI has a facility, not found in the Naming Service Specification, that permits some other Java object to synthesize a Java object out of \u0026ldquo;raw materials\u0026rdquo;, any of which may be bound in a tree rooted at any Context. This object doing the synthesizing is called an ObjectFactory. A JNDI implementation itself can supply ObjectFactory instances, but, more importantly for this article\u0026rsquo;s purposes, so can users and component providers.\nThis sounds complicated but is actually fairly simple.\nRecall that when you look something up in a JNDI tree rooted under a Context, you are blissfully unaware of the name resolution process (how the Object that is eventually delivered to you came to exist). Was it put together out of other things? Was it created out of nothing? Was it loaded from disk? Served over the network? You don\u0026rsquo;t know and you don\u0026rsquo;t care.\nFor certain cases, name resolution is absurdly simple: someone explicitly bound a textual string into a Context under, say, the name \u0026ldquo;hoopy\u0026quot;; you asked for the Object bound under \u0026ldquo;hoopy\u0026quot;; and lo and behold you got back that very string—perhaps \u0026ldquo;frood\u0026quot;—as a Java String object. Nothing fancy here.\nObjectFactory In other cases, an ObjectFactory gets involved. This happens because the Context::lookup operation delegates, in all implementations that I\u0026rsquo;m aware of, and perhaps explicitly stated somewhere, to a call to the NamingManager::getObjectInstance method, which pulls in ObjectFactory instances to actually perform the creation (or retrieval, or synthesis, or whatever) of a Java Object for a given Name.\nSo backing up from the minutiae for a moment, depending on what ObjectFactory instances are on the classpath and properly designated, a JNDI implementation may synthesize Objects out of thin air as if they were bound explicitly to various Names.\nObjectFactory instances and explicit binding can work together, too. An administrator can bind a Reference into a JNDI implementation that explicitly names the ObjectFactory to use to perform the actual name resolution.\nURL Context Factory One kind of ObjectFactory is one that plays the role of a URL context factory. These kinds of ObjectFactory implementations can create Contexts to represent particular URL schemes, such as, most infamously, java:, which is at the heart of the Java EE (and now Jakarta EE) specifications.\nThe notorious java:comp/env \u0026ldquo;prefix\u0026rdquo; is, more specifically, a URL whose semantics are strictly defined by the Java EE (now Jakarta EE) Platform Specification. java: causes a URL context factory specified by the Platform Specification to come into the picture, and comp/env is a compound name, relative to the root Context created by the URL context factory, denoting, by definition, a Context with very specific semantics. One of its specific semantics is very interesting to configuration systems, because it disambiguates component namespaces. That is, if an EJB refers to a Frood stored under the name hoopy, and another EJB refers to a Towel stored under the name hoopy, no conflict can occur, so long as hoopy is relative to java:comp/env in both cases.\nNo Java-centric configuration framework that I\u0026rsquo;m aware of other than JNDI addresses this extremely important concern.\nEvent Operations JNDI features events that can be fired when a bound object changes, or when an object has been added or removed.\nPutting It All Together So backing up to the conceptual level, JNDI provides the ability for two names to be used by two different components developed in isolation to refer to two different things, with at least the possibility that a name clash will not occur (one component\u0026rsquo;s java:comp/env Context is not the same Context as another component\u0026rsquo;s java:comp/env Context).\nIn addition, it allows for user-supplied factories to handle individual name resolution operations. There is a defined search order for discovering such factories. You supply a name, the system searches until it finds something that can make Objects for that name.\nJNDI properly separates the lookup use cases (ask for an Object of a particular type by name; receive it) from the binding and administration use cases (install an ObjectFactory that knows how to make an Object of a particular type; bind that ObjectFactory to a particular name), to such a degree that there could have been two specifications instead of one.\nOperations such as conversion and object binding are deliberately left unspecified, as it should be. That is, any given ObjectFactory may do whatever it wishes to come up with an Object for a given name resolution request.\nAt an abstract level, a compound name is a typed path, whose intermediate nodes may have known types as well.\nIf we strip some of the terminology and API cruft away we can say the following:\n In JNDI and configuration systems, there is some kind of root object to which notional paths are relative.  In JNDI this is a Context and the rootiest of all root Contexts is an InitialContext, as the name accurately reflects.   In JNDI and configuration systems, you locate an Object by supplying that root object with a typed path that designates the Object to retrieve.  In JNDI this is a CompoundName supplied to the Context::lookup method, and if you need to figure out what the type is, you can invoke any of several crufty methods to find the relevant Class.   In JNDI and configuration systems, some accessory piece of technology that is registered under that typed path is actually responsible for making the requested Object come into existence.  In JNDI, this is an ObjectFactory invoked by way of the NamingManager::getObjectInstance method.    JNDI Flaws So is JNDI the hipster configuration system that has been hiding in plain sight? Yes and no.\nWe\u0026rsquo;ve seen that it gets the separation of concerns right, and that its lookup features are relatively simple, and that it is unique among configuration systems in understanding the importance of namespaces. But there are plenty of problems.\nNo Generics First of all, in modern Java, you may not be looking for a List under a specific name, but a List\u0026lt;String\u0026gt;. JNDI predates generics, so you\u0026rsquo;ll have to do a lot of casting when you use this API.\nBinding and Lookup Services Colocated Next, a Context has a rather large number of methods because the lookup and binding services were combined into one interface. In hindsight, this was a mistake.\nVague Qualifiers Context instances have the ability to have \u0026ldquo;environments\u0026rdquo;, which are Hashtables (yes, Hashtables; JNDI predates the collections APIs) but whose purpose is left vague. Like any specification that features an untyped bag of named properties, this is usually a sign that some aspect of the problem domain wasn\u0026rsquo;t really understood too well.\nIf you look at it one way, a Context\u0026rsquo;s environment is really additional qualifiers qualifying lookups. For configuration system purposes, this concept, which I\u0026rsquo;ve argued is necessary, needs to be tightened up a little bit.\nToo Many Checked Exceptions JNDI was created when checked exceptions were all the rage. This makes using it in today\u0026rsquo;s Java projects laborious and unpleasant. Easy use cases, like using a default value in case a bound value is not present, are quite difficult as a result.\nCan\u0026rsquo;t Use Class or Type as a Selector The fact that it is a Name, and not some other kind of key, that is used to select Objects is mostly arbitrary and rooted in CORBA\u0026rsquo;s distributed objects background. For Java-centric configuration systems, what matters most of the time is the type of Object the caller is seeking. Names in this use case are secondary and used mostly to disambiguate, for example, one kind of Frood from another kind of Frood (perhaps the caller wants the hoopy Frood and not the unnamed Frood). JNDI requires that there be names for everything, even where they are superfluous.\nStrange Service Provider Location Machinery JNDI predates the java.util.ServiceLoader class, so it\u0026rsquo;s no surprise that its mechanism for finding service provider classes is a bit arcane.\nToo Much Hierarchy As noted earlier, for configuration system purposes, a tree model is not necessary. In most specifications, if you find that something is not necessary, you leave it out. There doesn\u0026rsquo;t seem to be a need for there to be an intermediate Context \u0026ldquo;in between\u0026rdquo; any two name components, but it fit a mental model the Naming Service Specification authors were familiar with, and JNDI tracked that specification, so here we are.\nConclusion JNDI is an old and clunky API with solid conceptual underpinnings that addresses most, if not all, concerns that any Java-centric configuration system will encounter. It is worth using as a kind of rubric to check any configuration system implementation against for correctness.\nWhat\u0026rsquo;s Next In a future post, I hope to write about JAX-RS from a Java-centric configuration system perspective. Seen through this lens, JAX-RS is a very interesting system for acquiring Java Objects based on a combination of names and qualifiers and MIME types, auto-discovering providers and negotiating and resolving ambiguities. If you combine its concepts with JNDI\u0026rsquo;s notion of namespaces and self-bootstrapping, a design for a Java-centric configuration system falls out rather easily.\n","href":"/blog/java-configuration-jndi-and-naming-operations/","title":"Java Configuration: JNDI and Naming Operations"},{"content":"","href":"/tags/jndi/","title":"jndi"},{"content":"","href":"/tags/personal/","title":"personal"},{"content":"Hello and welcome to my new blog.\nMy old blog is still available.\n","href":"/blog/welcome/","title":"Welcome"},{"content":"Older Posts There is a prior version of this blog that contains my older posts.\nRecent Posts Recent posts may be found below.\n","href":"/blog/","title":"Blog"},{"content":"","href":"/authors/","title":"Authors"},{"content":"","href":"/categories/","title":"Categories"},{"content":"","href":"/page/","title":"Pages"},{"content":"","href":"/search/","title":"Search"},{"content":"","href":"/series/","title":"Series"}]
